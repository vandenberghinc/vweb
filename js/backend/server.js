/*
 * Author: Daan van den Bergh
 * Copyright: Â© 2022 - 2023 Daan van den Bergh.
 */

// ---------------------------------------------------------
// Libraries.

const https = require("https");
const http = require("http");
const libcrypto = require("crypto");
const libnodemailer = require('nodemailer');

// ---------------------------------------------------------
// Imports.

const {vlib, vhighlight} = require("./vinc.js");
const utils = require("./utils.js");
const Meta = require('./meta.js');
const Mail = require('./mail.js');
const Status = require("./status.js");
const Mutex = require("./mutex.js");
const Endpoint = require("./endpoint.js");
const Response = require("./response.js");
const Request = require("./request.js");
const FileWatcher = require("./file_watcher.js");
const Adyen = require("./payments/adyen.js");
const Paddle = require("./payments/paddle.js");
const {FrontendError} = utils;

// ---------------------------------------------------------
// The server object.
// @todo figure out with what settings nodejs should be started for heavy servers, for example larger memory size `--max-old-space-size`
// @todo implement usage of multiple cpu's using lib `cluster`.
// @todo when rendering pages the user could use a special OptimizeText() function which will be optimized for copy writing and seo when adding loading static files. Quite hard but would be sublime (writesonic is a good platform).

/*  @docs:
    @chapter: Backend
    @title: Server
    @description: 
        The backend server class.
        When the https parameters `certificate` and `private_key` are defined, the server will run automatically on http and https.
    @parameter:
        @name: production
        @description: Whether the server is in production more, or in development mode.
        @type: boolean
        @required: true
    @parameter:
        @name: ip
        @description: The ip where the server will run on.
        @type: string
        @required: true
    @parameter:
        @name: port
        @description: The port where the server will run on. Leave the port `null` to run on port `80` for http and on port `443` for https.
        @type: number
    @parameter:
        @name: tls
        @description: The tls settings to enable HTTPS.
        @type: object
        @required: false
        @attribute:
            @name: certificate
            @description: The path to the certificate.
            @type: string
        @attribute:
            @name: private_key
            @description: The path to the private key file.
            @type: string
        @attribute:
            @name: passphrase
            @description: The passphrase of the private key.
            @type: string
    @parameter:
        @name: domain
        @description: The full domain url without `http://` or `https://`.
        @type: string
        @required: true
    @parameter:
        @name: statics
        @description: Array with path's to static directories.
        @type: array[string]
        @required: true
    @parameter:
        @name: database
        @description: The path to the database directory.
        @type: string
        @required: true
    @parameter:
        @name: default_headers
        @description: Used to override the default headers generated by vweb. Leave parameter `default_headers` as `null` to let vweb automatically generate the default headers.
        @type: object
    @parameter:
        @name: favicon
        @description: The path to the favicon.
        @type: string
    @parameter:
        @name: token_expiration
        @description: The token a sign in token will be valid in seconds.
        @type: number
    @parameter:
        @name: enable_2fa
        @description: Enable 2fa for user authentication.
        @type: boolean
        @required: true
    @parameter:
        @name: enable_account_activation
        @description: Enable account activation by email after a user signs up.
        @type: boolean
        @required: true
    @parameter:
        @name: meta
        @description: The default meta object.
        @type: object, vweb.Meta
    @parameter:
        @name: company
        @type: object
        @description: Your company information.
        @attribute:
            @name: name
            @type: string
            @required: true
            @description: The name of your company.
        @attribute:
            @name: legal_name
            @type: string
            @required: true
            @description: The legal name of your company.
        @attribute:
            @name: street
            @type: string
            @required: true
            @description: The street name of your company's address.
        @attribute:
            @name: house_number
            @type: string
            @required: true
            @description: The house number or house name of your company's address.
        @attribute:
            @name: postal_code
            @type: string
            @required: true
            @description: The postal code or zip code of your company's address.
        @attribute:
            @name: city
            @type: string
            @required: true
            @description: The city of your company's address.
        @attribute:
            @name: province
            @type: string
            @required: true
            @description: The province or state of your company's address.
        @attribute:
            @name: country
            @type: string
            @required: true
            @description: The country name of your company's address.
        @attribute:
            @name: tax_id
            @type: string
            @required: true
            @description: The tax id of your company.
        @attribute:
            @name: type
            @type: string
            @description: The type of company.
        @attribute:
            @name: icon
            @type: string
            @required: true
            @description: The endpoint url path of your company's icon, png format. This must be an endpoint url since access to the file path is also required for creating invoices.
        @attribute:
            @name: stroke_icon
            @type: string
            @required: true
            @description: The endpoint url path of your company's stroke icon, png format. In payment invoices the stroke icon precedes the default icon. This must be an endpoint url since access to the file path is also required for creating invoices.
    @parameter:
        @name: smtp
        @description:
            The smpt arguments object.
            More information about the arguments can be found at the nodemailer <link https://nodemailer.com/smtp/>documentation<link>.
        @type: object
        @attributes:
            @name: sender
            @description:
                The smtp sender address may either be a string with the email address, e.g. `your@email.com`.
                Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
            @type: string, array
        @attributes:
            @name: host
            @description: The mail server's host address.
            @type: string
        @attributes:
            @name: port
            @description: The mail server's port.
            @type: number
        @attributes:
            @name: secure
            @description: Enable secure options.
            @type: boolean
        @parameter:
            @name: auth
            @description: The authentication settings.
            @type: object
            @attributes:
                @name: user
                @description: The email used for authentication.
                @type: string
            @attributes:
                @name: pass
                @description: The password used for authentication.
                @type: string
    @parameter:
        @name: payments
        @type: object
        @description: The arguments for the payment class. The `type` attribute is used to indicate the payment provider, the other attributes are arguments for the payment class.
        @attribute:
            @name: type
            @type: string
            @description: The payment provider name.
            @required: true
            @enum:
                @name: adyen
                @desc: Payment provider Adyen.
            @enum:
                @name: paddle
                @desc: Payment provider Paddle.
    @parameter:
        @name: google_tag
        @description: The google tag id.
        @type: string
    @parameter:
        @name: file_watcher
        @description: The file watcher arguments, define to enable file watching. The parameter may either be an FileWatcher object, an object with arguments or a string for the `source` argument. The process argument `--no-file-watcher` can always be used to temporarily disable the file watcher.
        @type: FileWatcher, object, string.
    @parameter:
        @name: mail_style
        @description: The mail settings to customize automatically generated mails.
        @type: object
        @attribute:
            @name: font
            @description: The font family.
            @type: string
        @attribute:
            @name: button_bg
            @description: The background color of the button's in your mails.
            @type: string

    @attribute:
        @name: on_2fa_mail
        @desc:
            When a 2fa mail is sent, the mail can be generated using a callback. Only when the mail body is not passed in the parameters of `send_2fa()`, the callback will be checked.
        @param:
            @name: code
            @description: The 2fa code.
        @param:
            @name: username
            @description: The user's username.
        @param:
            @name: email
            @description: The user's email.
        @param:
            @name: date
            @description: The current date in UTC format.
        @param:
            @name: ip
            @description: The client's ip address.
        @param:
            @name: device
            @description: The client's device string.
 */

// @tdo implement 3D secure "requires_action" status for a refund and payment intent.
// https://stripe.com/docs/payments/3d-secure

class Server {

    // Mimes for content type detection.
    // Must be defined before creating static endpoints.
    static content_type_mimes = [
        [".html", "text/html"],
        [".htm", "text/html"],
        [".shtml", "text/html"],
        [".css", "text/css"],
        [".xml", "application/xml"],
        [".gif", "image/gif"],
        [".jpeg", "image/jpeg"],
        [".jpg", "image/jpeg"],
        [".js", "application/javascript"],
        [".atom", "application/atom+xml"],
        [".rss", "application/rss+xml"],
        [".mml", "text/mathml"],
        [".txt", "text/plain"],
        [".jad", "text/vnd.sun.j2me.app-descriptor"],
        [".wml", "text/vnd.wap.wml"],
        [".htc", "text/x-component"],
        [".png", "image/png"],
        [".tif", "image/tiff"],
        [".tiff", "image/tiff"],
        [".wbmp", "image/vnd.wap.wbmp"],
        [".ico", "image/x-icon"],
        [".jng", "image/x-jng"],
        [".bmp", "image/x-ms-bmp"],
        [".svg", "image/svg+xml"],
        [".svgz", "image/svg+xml"],
        [".webp", "image/webp"],
        [".woff", "font/woff"],
        [".woff2", "font/woff2"],
        [".jar", "application/java-archive"],
        [".war", "application/java-archive"],
        [".ear", "application/java-archive"],
        [".json", "application/json"],
        [".hqx", "application/mac-binhex40"],
        [".doc", "application/msword"],
        [".pdf", "application/pdf"],
        [".ps", "application/postscript"],
        [".eps", "application/postscript"],
        [".ai", "application/postscript"],
        [".rtf", "application/rtf"],
        [".m3u8", "application/vnd.apple.mpegurl"],
        [".xls", "application/vnd.ms-excel"],
        [".eot", "application/vnd.ms-fontobject"],
        [".ppt", "application/vnd.ms-powerpoint"],
        [".wmlc", "application/vnd.wap.wmlc"],
        [".kml", "application/vnd.google-earth.kml+xml"],
        [".kmz", "application/vnd.google-earth.kmz"],
        [".7z", "application/x-7z-compressed"],
        [".cco", "application/x-cocoa"],
        [".jardiff", "application/x-java-archive-diff"],
        [".jnlp", "application/x-java-jnlp-file"],
        [".run", "application/x-makeself"],
        [".pl", "application/x-perl"],
        [".pm", "application/x-perl"],
        [".prc", "application/x-pilot"],
        [".pdb", "application/x-pilot"],
        [".rar", "application/x-rar-compressed"],
        [".rpm", "application/x-redhat-package-manager"],
        [".sea", "application/x-sea"],
        [".swf", "application/x-shockwave-flash"],
        [".sit", "application/x-stuffit"],
        [".tcl", "application/x-tcl"],
        [".tk", "application/x-tcl"],
        [".der", "application/x-x509-ca-cert"],
        [".pem", "application/x-x509-ca-cert"],
        [".crt", "application/x-x509-ca-cert"],
        [".xpi", "application/x-xpinstall"],
        [".xhtml", "application/xhtml+xml"],
        [".xspf", "application/xspf+xml"],
        [".zip", "application/zip"],
        [".bin", "application/octet-stream"],
        [".exe", "application/octet-stream"],
        [".dll", "application/octet-stream"],
        [".deb", "application/octet-stream"],
        [".dmg", "application/octet-stream"],
        [".iso", "application/octet-stream"],
        [".img", "application/octet-stream"],
        [".msi", "application/octet-stream"],
        [".msp", "application/octet-stream"],
        [".msm", "application/octet-stream"],
        [".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
        [".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
        [".pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
        [".mid", "audio/midi"],
        [".midi", "audio/midi"],
        [".kar", "audio/midi"],
        [".mp3", "audio/mpeg"],
        [".ogg", "audio/ogg"],
        [".m4a", "audio/x-m4a"],
        [".ra", "audio/x-realaudio"],
        [".3gpp", "video/3gpp"],
        [".3gp", "video/3gpp"],
        [".ts", "video/mp2t"],
        [".mp4", "video/mp4"],
        [".mpeg", "video/mpeg"],
        [".mpg", "video/mpeg"],
        [".mov", "video/quicktime"],
        [".webm", "video/webm"],
        [".flv", "video/x-flv"],
        [".m4v", "video/x-m4v"],
        [".mng", "video/x-mng"],
        [".asx", "video/x-ms-asf"],
        [".asf", "video/x-ms-asf"],
        [".wmv", "video/x-ms-wmv"],
        [".avi", "video/x-msvideo"],
    ]

    // Constructor.
    constructor({
        ip = "127.0.0.1",
        port = 8000,
        domain = null,
        statics = [],
        database = null,
        favicon = null,
        company = null,
        meta = new Meta(),
        tls = null,
        smtp = null,
        mail_style = {
            font: '"Helvetica", sans-serif',
            title_fg: "#121B23",
            subtitle_fg: "#121B23",
            text_fg: "#1F2F3D",
            button_fg: "#FFFFFF",
            footer_fg: "#686B80",
            bg: "#EEEEEE",
            widget_bg: "#FFFFFF",
            widget_border: "#E6E6E6",
            button_bg: "#1F2F3D",
            divider_bg: "#706780",
        },
        payments = null,
        default_headers = null,
        google_tag = null,
        token_expiration = 86400,
        enable_2fa = false,
        enable_account_activation = true,
        production = false,
        file_watcher = null,
    }) {

        // Verify args.
        vlib.utils.verify_params(arguments[0], {
            ip: "string",
            domain: "string",
            statics: "array",
            database: "string",
            favicon: {type: "string", required: false},
            company: {
                type: "object",
                attrs: {
                    name: "string",
                    legal_name: "string",
                    street: "string",
                    house_number: "string",
                    postal_code: "string",
                    city: "string",
                    province: "string",
                    country: "string",
                    tax_id: {type: "string", default: null},
                    icon: {type: "string", default: null},
                    stroke_icon: {type: "string", default: null},
                }
            },
            meta: {type: "object", required: false},
            tls: {
                type: ["null", "object"],
                required: false,
                attrs: {
                    certificate: "string",
                    private_key: "string",
                }
            },
            smtp: {type: ["null", "object"], required: false},
            mail_style: {
                type: "object",
                attrs: {
                    font: {type: "string", default: '"Helvetica", sans-serif'},
                    title_fg: {type: "string", default: "#121B23"},
                    text_fg: {type: "string", default: "#1F2F3D"},
                    button_fg: {type: "string", default: "#FFFFFF"},
                    footer_fg: {type: "string", default: "#686B80"},
                    bg: {type: "string", default: "#EEEEEE"},
                    widget_bg: {type: "string", default: "#FFFFFF"},
                    button_bg: {type: "string", default: "#421959"},
                    widget_border: {type: "string", default: "#E6E6E6"},
                    divider_bg: {type: "string", default: "#E6E6E6"},
                }
            },
            payments: {type: ["null", "object"], required: false},
            default_headers: {type: ["null", "object"], required: false},
            google_tag: {type: "string", required: false},
            token_expiration: {type: "number", required: false},
            enable_2fa: {type: "boolean", required: false},
            enable_account_activation: {type: "boolean", required: false},
            production: {type: "boolean", required: false},
            file_watcher: {type: ["null", "string"], required: false},
        });

        // Assign attributes directly.
        this.port = port;
        this.ip = ip;
        this.favicon = favicon;
        this.enable_2fa = enable_2fa;
        this.enable_account_activation = enable_account_activation;
        this.token_expiration = token_expiration;
        this.google_tag = google_tag;
        this.production = production;
        this.company = company;
        this.mail_style = mail_style;

        // Set domain.
        this.domain = domain.replace("https://","").replace("http://","");
        while (this.domain.length > 0 && this.domain.charAt(this.domain.length - 1) === "/") {
            this.domain = this.domain.substr(0, this.domain.length - 1)
        }

        // Set full domain.
        this.full_domain = `http${tls == null || tls.private_key === null ? "" : "s"}://${domain}`; // also required for Stripe.

        // Set statics.
        this.statics = [];
        let export_static;
        statics.iterate((path) => {
            path = new vlib.Path(path).abs();
            if (export_static === undefined && path.name() === "static") {
                export_static = path;
            }
            if (this.statics.includes(path) === false) {
                this.statics.push(path);
            }
        });
        if (export_static === undefined) {
            throw Error("The static directories must at least include one directory named \"static\".");
        }

        // Set database.
        this.database = new vlib.Path(database).abs();

        // Set meta.
        if (meta instanceof Meta === false) {
            meta = new Meta(meta);
        }
        if (favicon != null && meta.favicon == null) {
            meta.favicon = this.full_domain + "/favicon.ico";
        }
        if (favicon != null && meta.image == null) {
            meta.favicon = this.full_domain + "/favicon.ico";
        }
        this.meta = meta;

        // Default headers.
        if (default_headers === null) {
            this.csp = {
                "default-src": "'self' https://*.google-analytics.com",
                "img-src": `'self' http://${this.domain} https://${this.domain} https://*.google-analytics.com https://raw.githubusercontent.com/vandenberghinc/ `,
                "script-src": "'self' 'unsafe-inline' https://ajax.googleapis.com https://www.googletagmanager.com https://googletagmanager.com https://*.google-analytics.com https://code.jquery.com https://cdn.jsdelivr.net/npm/@vandenberghinc/",
                "style-src": "'self' 'unsafe-inline' https://cdn.jsdelivr.net/npm/@vandenberghinc/",
            }
            this.default_headers = {
                "Vary": "Origin",
                "Referrer-Policy": "same-origin",
                "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
                "X-XSS-Protection": "1; mode=block",
                "X-Content-Type-Options": "frame-ancestors 'none'; nosniff;",
                "X-Frame-Options": "DENY",
                "Strict-Transport-Security": "max-age=31536000",
            }
        } else {
            if (default_headers["Content-Security-Policy"] != null && typeof default_headers["Content-Security-Policy"] !== "object") {
                throw Error("The Content-Security-Policy of the default headers must be an object with values for each csp key, e.g. \"{'script-src': '...'}\".");
            }
            this.csp = default_headers["Content-Security-Policy"] != null ? default_headers["Content-Security-Policy"] : {
                "default-src": "'self' https://*.google-analytics.com",
                "img-src": `'self' http://${this.domain} https://${this.domain} https://*.google-analytics.com https://raw.githubusercontent.com/vandenberghinc/ `,
                "script-src": "'self' 'unsafe-inline' https://ajax.googleapis.com https://www.googletagmanager.com https://googletagmanager.com https://*.google-analytics.com https://code.jquery.com https://cdn.jsdelivr.net/npm/@vandenberghinc/",
                "style-src": "'self' 'unsafe-inline' https://cdn.jsdelivr.net/npm/@vandenberghinc/",
            }
            this.default_headers = default_headers;
        }

        // Initialize payments.
        if (payments) {
            if (payments.type === "adyen") {
                this.payments = new Adyen({
                    _server: this,
                    ...payments,
                })
            } else if (payments.type === "paddle") {
                this.payments = new Paddle({
                    _server: this,
                    ...payments,
                })
            } else {
                throw Error(`Invalid payment processor type "${payments.type}", valid types are "paddle" or "adyen".`)
            }
        }

        // Define your list of endpoints
        this.endpoints = [];

        // Copy the default static directory.
        // Must be before the file watcher is initialized.
        const sync_dir = async (from, to) => {
            if (to.exists() === false) {
                from.cp_sync(to);
                return ;
            }
            const paths = from.paths_sync().iterate_append((item) => {
                return item.str().substr(from.length);
            });
            paths.iterate_async_await((subpath) => {
                const src = from.join(subpath)
                const dest = to.join(subpath);
                if (dest.exists() === false || src.mtime > dest.mtime) {
                    src.cp_sync(dest)
                }
            })
        }
        const src_static = new vlib.Path(`${__dirname}/../static/`).abs();
        sync_dir(src_static.join("payments"), export_static.join("payments"));

        // File watcher.
        if (process.argv.includes("--no-file-watcher") === false && file_watcher != null && process.env.VWEB_FILE_WATCHER != '1') {

            // Create default endpoints.
            let additional_paths = this._create_default_endpoints();

            // Create static endpoints.
            this.statics.iterate((path) => {
                additional_paths = additional_paths.concat(this._create_static_endpoints(path.base(), path));
            });

            // Add the vweb backend source files to the additional files.
            additional_paths.push(__dirname);

            // Initialize file watcher.
            if (typeof file_watcher === "string" || file_watcher instanceof vlib.Path) {
                this.file_watcher = new FileWatcher({source: file_watcher});
            }
            else if (file_watcher instanceof FileWatcher) {
                this.file_watcher = file_watcher;
            } else {
                this.file_watcher = new FileWatcher(file_watcher);
            }
            this.file_watcher.excluded.push(this.database.str());

            // Add default and static endpoints.
            this.file_watcher.additional_paths = additional_paths;
            
            // Start.
            this.file_watcher.start();
            return ;
        }

        // The smtp instance.
        if (smtp) {
            this.smtp_sender = smtp.sender;
            this.smtp = libnodemailer.createTransport(smtp);
        }
        
        // Create an HTTPS server
        if (tls) {
            this.https = https.createServer(
                {
                    key: new vlib.Path(tls.private_key).load_sync('utf8'), 
                    cert: new vlib.Path(tls.certificate).load_sync('utf8'), 
                    passphrase: tls.passphrase
                },
                (request, response) => this._serve(request, response)
            );
        }

        // Create an HTTP server
        this.http = http.createServer((request, response) => this._serve(request, response));

        // Max uid.
        this.max_uid = null;
        this.edit_max_uid_mutex = new Mutex();

        // The master sha256 hash key.
        this.hash_key = null;
    }

    // ---------------------------------------------------------
    // Utils (private).

    // Initialize the default headers.
    _initialize_default_headers() {
        let csp = "";
        Object.keys(this.csp).iterate((key) => {
            csp += key;
            const value = this.csp[key];
            if (typeof value === "string" && value.length > 0) {
                csp += " ";
                csp += value;
            }
            csp += ";";
        });
        this.default_headers["Content-Security-Policy"] = csp;
    }

    // Iterate a subpath directory in the database.
    async _iter_db_dir(subpath, callback) {
        return this.database.join(subpath).paths_sync().iterate_async_await((path) => {
            if (path.name() !== ".DS_Store") {
                return callback(path);
            }
        });
    }

    // Check of the uid is within the max uid range.
    _check_uid_within_range(uid) {
        if (uid == null || uid < 0 || uid == "") {
            throw Error("Undefined user id.");
        }
        else if (uid > this.max_uid) {
            throw Error(`User id "${uid}" does not exist.`);
        }
    }

    // Get a content type from an extension.
    _sys_get_content_type(extension) {
        let content_type = Server.content_type_mimes.iterate((item) => {
            if (item[0] == extension) {
                return item[1];
            }
        })
        if (content_type == null) {
            content_type = "application/octet-stream";
        }
        return content_type;
    }

    // Generate a key.
    _sys_generate_key(path) {
        const length = 32;
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Generate a crypto key.
    _sys_generate_crypto_key(length = 32) {
        return libcrypto.randomBytes(length).toString('hex');
    }

    // Generate a 2fa code.
    _sys_generate_2fa() {
        const length = 6;
        const charset = "0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Load data into an object formatted line by line.
    // All data will be loaded as a string.
    // When the path does not exists the input object will be returned.
    _sys_load_data_into_obj(path, obj = {}, keys = []) {
        if (!path.exists()) {
            return obj;
        }
        const data = path.load_sync();
        let key = 0;
        const info = {line: "", line_number: 0}
        for (let i = 0; i < data.length; i++) {
            const c = data.charAt(i);
            if (c == '\n') {
                if (obj[keys[key]] == null) {
                    obj[keys[key]] = "";
                }
                ++key;
            } else {
                if (obj[keys[key]] == null) {
                    obj[keys[key]] = "";
                }
                obj[keys[key]] += c;
            }
        }
        // for (let i = key; i < keys.length; i++) {
        //     obj[keys[i]] = "";
        // }
        return obj;
    }

    // Save an object to data formatted line by line.
    _sys_save_data_into_obj(path, obj, keys) {
        let data = "";
        for (let i = 0; i < keys.length; i++) {
            if (typeof obj[keys[i]] === "string") {
                data += obj[keys[i]];
            } else {
                data += obj[keys[i]].toString();
            }
            data += "\n";
        }
        path.save_sync(data);
    }

    // Save or delete uid by username,
    _sys_save_uid_by_username(uid, username) {
        this.database.join(`.sys/usernames/${username}`, false).save_sync(uid.toString());
    }
    _sys_delete_uid_by_username(username) {
        this.database.join(`.sys/usernames/${username}`, false).del_sync();
    }

    // Save or delete uid by email,
    _sys_save_uid_by_email(uid, email) {
        this.database.join(`.sys/emails/${email}`, false).save_sync(uid.toString());
    }
    _sys_delete_uid_by_email(email) {
        this.database.join(`.sys/emails/${email}`, false).del_sync();
    }

    /*  Save, load or delete a system user object.
        An object has the following keys if the user is not deleted: 
        When adding additional fields the min keys length for detailed data detection inside `set_user` should be updated.
        {
            uid: number,
            first_name: string,
            last_name: string,
            username: string,
            email: string,
            password: string,
            api_key: string,
            phone_number: string,
        }
     */
    _sys_load_user(uid) {
        return this._sys_load_data_into_obj(this.database.join(`.sys/users/${uid}`, false), {uid: uid}, [
            "first_name",
            "last_name",
            "username",
            "email",
            "password",
            "api_key",
            "phone_number",
        ]);
    }
    _sys_save_user(uid, user) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/users/${uid}`, false), 
            user, 
            [
                "first_name",
                "last_name",
                "username",
                "email",
                "password",
                "api_key",
                "phone_number",
            ],
        );
    }
    _sys_load_detailed_user(uid) {
        const path = this.database.join(`.sys/users/${uid}.detailed`, false);
        if (path.exists() === false) {
            const data = {
                created: Date.now(),
            };
            path.save_sync(data);
            return data;
        }
        return data.load_sync({type: "object"});
    }
    _sys_save_detailed_user(uid, data) {
        this.database.join(`.sys/users/${uid}.detailed`, false).save_sync(data);
    }

    // @todo the parameter requires the full sys user object.
    _sys_delete_user(user) {
        if (typeof user === "number" || typeof user === "string") {
            user = this.get_user(user);
        }
        this.database.join(`.sys/users/${user.uid}`, false).del_sync();
        this.database.join(`.sys/users/${user.uid}.detailed`, false).del_sync();
        this._sys_delete_uid_by_username(user.username);
        this._sys_delete_uid_by_email(user.email);
        this.database.join(`.sys/support_pin/${uid}`, false).del_sync();
        this.database.join(`users/${uid}`, false).del_sync();
        if (this.payments) {
            this.payments._sys_delete_user(user);
        }
    }

    /*  Save, load or delete a system user token object used for signin in.
        An object has the following keys if the token exists:
        {
            expiration: number,
            token: string,
        }
     */
    _sys_load_user_token(uid) {
        const obj = this._sys_load_data_into_obj(this.database.join(`.sys/tokens/${uid}`, false), {expiration: 0}, [
            "expiration",
            "token",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_token(uid, token) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/tokens/${uid}`, false), 
            token,
            [
               "expiration",
                "token",
            ],
        );
    }
    _sys_delete_user_token(uid) {
        this.database.join(`.sys/tokens/${uid}`, false).del_sync();
    }

    /*  Save, load or delete a system user 2fa object used for two factor authentication.
        An object has the following keys if the token exists:
        {
            expiration: number,
            code: string,
        }
     */
    _sys_load_user_2fa(uid) {
        const obj = this._sys_load_data_into_obj(this.database.join(`.sys/2fa/${uid}`, false), {expiration: 0}, [
            "expiration",
            "code",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_2fa(uid, token) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/2fa/${uid}`, false), 
            token,
            [
                "expiration",
                "code",
            ]
        );
    }
    _sys_delete_user_2fa(uid) {
        this.database.join(`.sys/2fa/${uid}`, false).del_sync();
    }

    // Load user data helper.
    _sys_load_user_data(uid, subpath, def, privacy) {
        // Check uid.
        this._check_uid_within_range(uid);

        // Check path.
        if (subpath.indexOf("..") !== -1) {
            throw Error(`Permission denied (path-injection).`);
        }
        const path = this.database.join(`users/${uid}/${privacy}/${subpath}`, false).abs();
        if (path.str().eq_first(`${this.database}/users/${uid}/${privacy}/`) === false) {
            throw Error(`Permission denied (path-injection).`);
        }

        // Does not exist.
        if (!path.exists()) {
            return def;
        }

        // Load data.
        let data = path.load_sync();

        // Cast data.
        if (def == null || typeof def === "string") {
            return data;
        } else if (typeof def === "boolean") {
            return data === "true" || data === "1" || data === "True" || data === "TRUE";
        } else if (typeof def === "number") {
            return parseFloat(data);
        } else if (Array.isArray(def)) {
            return JSON.parse(data);
        } else if (typeof def === "object") {
            data = JSON.parse(data);
            Object.keys(def).iterate((key) => {
                if (data[key] === undefined) {
                    data[key] = def[key];
                }
            })
            return data;
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
        }
    }

    // Save user data helper.
    _sys_save_user_data(uid, subpath, privacy) {

        // Check uid.
        this._check_uid_within_range(uid);

        // Check path.
        if (subpath.indexOf("..") !== -1) {
            throw Error(`Permission denied (path-injection).`);
        }
        const path = this.database.join(`users/${uid}/${privacy}/${subpath}`, false).abs();
        if (path.str().eq_first(`${this.database}/users/${uid}/${privacy}/`) === false) {
            throw Error(`Permission denied (path-injection).`);
        }

        // Create base.
        const base = path.base();
        if (base.exists() === false) {
            base.mkdir_sync();
        }
        return path;
    }

    // Load system data for the user, so not from the vweb ".sys" directory but from the "sys" directory.
    _sys_load_sys_data(subpath, def) {
        
        // Check path.
        const path = this.database.join(`sys/${subpath}`, false)

        // Does not exist.
        if (!path.exists()) {
            return def;
        }

        // Load data.
        let data = path.load_sync();

        // Cast data.
        if (def == null || typeof def === "string") {
            return data;
        } else if (typeof def === "boolean") {
            return data === "true" || data === "1" || data === "True" || data === "TRUE";
        } else if (typeof def === "number") {
            return parseFloat(data);
        } else if (Array.isArray(def)) {
            return JSON.parse(data);
        } else if (typeof def === "object") {
            data = JSON.parse(data);
            Object.keys(def).iterate((key) => {
                if (data[key] === undefined) {
                    data[key] = def[key];
                }
            })
            return data;
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
        }
    }

    // Create a sha hmac with the master key.
    _hmac(data) {
        const hmac = libcrypto.createHmac("sha256", this.hash_key);
        hmac.update(data);
        return hmac.digest("hex");
    }

    // Check a password and the verify password.
    _verify_new_pass(pass, verify_pass) {
        if (pass !== verify_pass) {
            return "Passwords do not match.";
        } else if (pass.length < 8) {
            return "The password should at least include eight characters.";
        } else if (pass.toLowerCase() === pass) {
            return "The password should at least include one capital letter.";
        } else if (pass.includes_numeric_char() === false && pass.includes_special_char() === false) {
            return "The password should at least include one numeric or special character.";
        }
    }

    // ---------------------------------------------------------
    // Authentication (private).

    // Generate a token by uid.
    _generate_token(uid) {
        this._check_uid_within_range(uid);
        const token = `1${uid}:${this._sys_generate_key()}`;
        this._sys_save_user_token(uid, {
            expiration: Date.now() + this.token_expiration * 1000,
            token: this._hmac(token),
        });
        return token;
    }

    // Perform authentication on a request.
    // When the authentication has failed an args object for response.send will be returned.
    // On a successfull authentication `null` will be returned.
    async _authenticate(request) {

        // // Get api key key from bearer.
        const authorization = request.headers["authorization"];
        if (authorization !== undefined) {
            if (typeof authorization !== "string") {
                return {
                    status: 400, 
                    data: "Bad Request: Invalid authorization header.",
                };
            }
            if (!authorization.eq_first("Bearer ")) {
                return {
                    status: 400, 
                    data: "Bad Request: Invalid authorization scheme, the authorization scheme must be \"Bearer\".",
                };
            }
            let api_key = "";
            for (let i = 7; i < authorization.length; i++) {
                const c = authorization[i];
                if (c == " ") {
                    continue;
                }
                api_key += c;
            }
            const uid = await this.get_uid_by_api_key(api_key);
            if (await this.verify_api_key_by_uid(uid, api_key) !== true) {
                return {
                    status: Status.unauthorized, 
                    data: "Unauthorized.",
                };

            }
            request.uid = uid;
            return null;
        }

        // Get token from cookies.
        else {
            if (request.cookies.T == null || request.cookies.T.value == null) {
                return {
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                };
            }
            const token = request.cookies.T.value;
            const uid = await this.get_uid_by_api_key(token);
            if (await this.verify_token_by_uid(uid, token) !== true) {
                return {
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                };

            }
            request.uid = uid;
            return null;
        }

        // Authentication failed.
        return {
            status: 302, 
            headers: {"Location": `/signin?next=${request.url}`},
            data: "Permission denied.",
        };
    }

    // Sign a user in and return a response.
    async _sign_in_response(response, uid) {

        // Generate token.
        const token = this._generate_token(uid);
        
        // Create headers.
        this._create_token_cookie(response, token);
        await this._create_user_cookie(response, uid);
        await this._create_detailed_user_cookie(response, uid);
            
        // Response.
        response.send({
            status: 200,
            data: {message: "Successfully signed in."}
        });
    }

    // ---------------------------------------------------------
    // Headers (private).

    // Add header defaults.
    _set_header_defaults(response) {
        response.set_headers(this.default_headers);
        // if (this.domain != null) {
        //     response.set_header("Origin", this.domain);
        //     response.set_header("Access-Control-Allow-Origin", this.domain);
        // }
    }
    
    // Create token headers.
    //  - Should be called when generating a token.
    _create_token_cookie(response, token) {
        response.set_header("Cache-Control", "max-age=0, no-cache, no-store, must-revalidate, proxy-revalidate");
        response.set_header("Access-Control-Allow-Credentials", "true");
        let expires = new Date(new Date().getTime() + this.token_expiration * 1000);
        if (typeof token === "object") {
            token = token.token;
        }
        response.set_cookie(`T=${token}; Max-Age=86400; Path=/; Expires=${expires.toUTCString()}; SameSite=None; ${this.https === undefined ? "" : "Secure"}; HttpOnly;`);
    }
    
    // Create user headers.
    //  - Should be called when a user is authenticated.
    async _create_user_cookie(response, uid) {
        const secure = this.https === undefined ? "" : "Secure";
        if (uid != null && uid >= 0 && uid <= this.max_uid) {
            response.set_cookie(`UserID=${uid}; Path=/; SameSite=None; ${secure};`);
            const is_activated = this.enable_account_activation ? await this.is_activated(uid) : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=None; ${secure};`);
        } else {
            response.set_cookie(`UserID=-1; Path=/; SameSite=None; ${secure};`);
            const is_activated = this.enable_account_activation ? false : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=None; ${secure};`);
        }
    }
    
    // Create user headers.
    //  - Should be called when a user has just signed in, signed up or changed their account.
    async _create_detailed_user_cookie(response, uid) {
        const secure = this.https === undefined ? "" : "Secure";
        const user = await this.get_user(uid);
        response.set_cookie(`UserName=${user.username}; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserFirstName=${user.first_name}; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserLastName=${user.last_name}; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserEmail=${user.email}; Path=/; SameSite=None; ${secure};`);
    }
    
    // Reset all default cookies.
    // - Should be called when a user signs out.
    _reset_cookies(response) {
        const secure = this.https === undefined ? "" : "Secure";
        response.set_cookie(`T=; Path=/; SameSite=None; ${secure}; HttpOnly;`);
        response.set_cookie(`UserID=-1; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserActivated=false; Path=/; SameSite=None; ${secure};`);
        // response.set_cookie(`2FAUserID=-1; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserName=; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserFirstName=; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserLastName=; Path=/; SameSite=None; ${secure};`);
        response.set_cookie(`UserEmail=; Path=/; SameSite=None; ${secure};`);
    }

    // ---------------------------------------------------------
    // Endpoints (private).

    // Find endpoint.
    _find_endpoint(endpoint, method = null) {
        return this.endpoints.iterate((end) => {
            if (end.endpoint == endpoint && (method == null || method == end.method)) {
                return endpoint;
            }
        })
    }

    // Create static endpoints.
    _create_static_endpoints(base, dir) {
        const exclude = [".DS_Store"]
        let paths = [];
        dir.paths_sync().iterate((path) => {

            // Excluded.
            if (exclude.includes(path.name())) {
                return null;
            }

            // Add to paths.
            paths.push(path.str());

            // Read dir recursively.
            if (path.is_dir()) {
                paths = paths.concat(this._create_static_endpoints(base, path));
            }

            // Add file.
            else {
                let subpath = path.str().substr(base.length)
                if (subpath.charAt(0) != "/") {
                    subpath = "/" + subpath;
                }
                let data;
                if (path.extension() === ".js") {
                    data = path.load_sync();
                    const compiler = new vhighlight.JSCompiler({
                        line_breaks: true,
                        double_line_breaks: false,
                        comments: false,
                        white_space: false,
                    })
                    data = compiler.compile_code(data, path.str());
                } else {
                    data = path.load_sync({type: null});
                }
                this.endpoint(new Endpoint({
                    method: "GET",
                    endpoint: subpath,
                    data: data,
                    content_type: this._sys_get_content_type(path.extension()),
                    _path: path.str(),
                }))
            }
        })
        return paths;
    }

    // Create default endpoints.
    _create_default_endpoints() {

        // Vars.
        const additional_file_watcher_paths = [];

        // Add favicon.
        if (this.favicon != null) {
            const favicon = new vlib.Path(this.favicon);
            if (favicon.exists() === false) {
                throw Error(`Specified favicon path "${favicon}" does not exist.`);
            }
            this.endpoint(new Endpoint({
                method: "GET",
                endpoint: "/favicon.ico",
                data: favicon.load_sync({type: null}),
                content_type: this._sys_get_content_type(favicon.extension()),
            }))
            additional_file_watcher_paths.push(favicon.str());
        }

        // Default static endpoints.
        const defaults = [
            {
                method: "GET",
                endpoint: "/vweb/vweb.css",
                content_type: "text/css",
                path: new vlib.Path(`${__dirname}/../frontend/css/vweb.css`),
            },
            {
                method: "GET",
                endpoint: "/vweb/vweb.js",
                content_type: "application/javascript",
                path: new vlib.Path(`${__dirname}/../frontend/min/vweb.js`),
                templates: {
                    GOOGLE_TAG: this.google_tag,
                }
            },
            {
                method: "GET",
                endpoint: "/vhighlight/vhighlight.css",
                content_type: "text/css",
                path: new vlib.Path(vhighlight.web_exports.css),
            },
            {
                method: "GET",
                endpoint: "/vhighlight/vhighlight.js",
                content_type: "application/javascript",
                path: new vlib.Path(vhighlight.web_exports.js),
            },
            {
                method: "GET",
                endpoint: "/vweb/payments/adyen.js",
                content_type: "application/javascript",
                path: new vlib.Path(`${__dirname}/../frontend/min/adyen.js`),
                templates: {
                    ADYEN_ENV: this.production ? "live" : "test",
                    ADYEN_CLIENT_KEY: this.payments ? this.payments.client_key : "",
                }
            },
            {
                method: "GET",
                endpoint: "/vweb/payments/adyen.css",
                content_type: "text/css",
                path: new vlib.Path(`${__dirname}/../frontend/css/adyen.css`),
            },
            {
                method: "GET",
                endpoint: "/vweb/payments/paddle.js",
                content_type: "application/javascript",
                path: new vlib.Path(`${__dirname}/../frontend/min/paddle.js`),
                templates: {
                    PADDLE_SANDBOX: this.payments ? this.payments.sandbox : true,
                    PADDLE_CLIENT_KEY: this.payments ? this.payments.client_key : "",
                    PADDLE_INCLUSIVE_TAX: this.payments ? this.payments.inclusive_tax : null,
                }
            },
        ]
        defaults.iterate((item) => {
            let data = item.path.load_sync();
            if (item.templates != null) {
                data = utils.fill_templates(data, item.templates);
            }
            this.endpoint(new Endpoint({
                method: item.method,
                endpoint: item.endpoint,
                data: data,
                content_type: item.content_type,
                compress: item.compress,
            }))
            additional_file_watcher_paths.push(item.path.str());
        })


        // ---------------------------------------------------------
        // Default auth endpoints.
        
        this.endpoint(
            
            // Send 2fa.
            {
                method: "GET",
                endpoint: "/vweb/auth/2fa",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    email: "string",
                },
                callback: async (request, response, params) => {
                    
                    // Get uid.
                    let uid;
                    if ((uid = await this.get_uid_by_email(params.email)) == null) {
                        return response.success({
                            data: {message: "A 2FA code was sent if the specified email exists."},
                        });
                    }
                    
                    // Send.
                    await this.send_2fa({uid:uid, request:request});
                    return response.success({
                        data: {message: "A 2FA code was sent if the specified email exists."},
                    });
                    
                }
            },
        
            // Sign in.
            {
                method: "POST",
                endpoint: "/vweb/auth/signin",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {

                    // Get params.
                    let email, email_err, username, username_err, password, uid, code;
                    try {
                        email = request.param("email")
                    } catch (err) {
                        email_err = err;
                    }
                    try {
                        username = request.param("username")
                    } catch (err) {
                        username_err = err;
                    }
                    if (email_err && username_err) {
                        return response.error({status: Status.bad_request, data: {error: email_err.message}});
                    }
                    try {
                        password = request.param("password")
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Get uid.
                    if (email) {
                        if ((uid = await this.get_uid_by_email(email)) == null) {
                            return response.error({
                                status: Status.unauthorized,
                                data: {
                                    error: "Unauthorized.",
                                    invalid_fields: {
                                        "email": "Invalid or unrecognized email",
                                        "password": "Invalid or unrecognized password",
                                    },
                                }
                            });
                        }
                    } else {
                        if ((uid = await this.get_uid(username)) == null) {
                            return response.error({
                                status: Status.unauthorized,
                                data: {
                                    error: "Unauthorized.",
                                    invalid_fields: {
                                        "username": "Invalid or unrecognized username",
                                        "password": "Invalid or unrecognized password",
                                    },
                                }
                            });
                        }
                    }
                    
                    // Verify password.
                    if (await this.verify_password(uid, password)) {
                        
                        // Verify 2fa.
                        if (this.enable_2fa) {

                            // Get 2FA.
                            try {
                                code = request.param("2fa")
                            } catch (err) {
                                await this.send_2fa({uid:uid, request:request});
                                return response.send({
                                    status: Status.two_factor_auth_required,
                                    data: {error: "2FA required."}
                                });
                            }

                            // Verify 2FA.
                            if (await this.verify_2fa(uid, code) !== true) {
                                return response.send({
                                    status: Status.unauthorized,
                                    data: {
                                        error: "Invalid 2FA code.",
                                        invalid_fields: {
                                            "2fa": "Invalid code",
                                        },
                                    }
                                });
                            }
                        }
                        
                        // Sign in.
                        return await this._sign_in_response(response, uid);
                    }

                    // Unauthorized.
                    return response.send({
                        status: Status.unauthorized,
                        data: {
                            error: "Unauthorized.",
                            invalid_fields: {
                                "username": "Invalid or unrecognized username",
                                "password": "Invalid or unrecognized password",
                            },
                        }
                    });
                }
            },
        
            // Sign out.
            {
                method: "POST",
                endpoint: "/vweb/auth/signout",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Delete token.
                    this._sys_delete_user_token(request.uid);
                    
                    // Create headers.
                    this._reset_cookies(response);
                    
                    // Response.
                    return response.success({
                        data: {message: "Successfully signed out."},
                    })
                }
            },
        
            // Sign up.
            {
                method: "POST",
                endpoint: "/vweb/auth/signup",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    username: "string",
                    first_name: "string",
                    last_name: "string",
                    email: "string",
                    password: "string",
                    verify_password: "string",
                    phone_number: {type: "string", default: ""},
                },
                callback: async (request, response, params) => {
                    
                    // Verify password.
                    const error = this._verify_new_pass(params.password, params.verify_password);
                    if (error) {
                        return response.error({
                            status: Status.bad_request,
                            data: {
                                error: error,
                                invalid_fields: {"password": error},
                            }
                        });
                    }
                    
                    // Create.
                    let uid;
                    try {
                        uid = await this.create_user(params);
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {
                            error: err.message,
                            invalid_fields: err.invalid_fields || {},
                        }});
                    }
                    
                    // Send 2fa code for activation.
                    if (this.enable_account_activation) {
                        await this.send_2fa({uid:uid, request:request});
                    }
                    
                    // Sign in.
                    return await this._sign_in_response(response, uid);
                    
                }
            },
        
            // Activate account.
            {
                method: "POST",
                endpoint: "/vweb/auth/activate",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    "2fa": "string",
                },
                callback: async (request, response, params) => {
                    
                    // Vars.
                    let uid = request.uid;
                    
                    // Get uid by cookie.
                    if (uid == null) {
                        const value = request.cookies["UserID"].value;
                        if (value != null && value != "-1") {
                            uid = parseInt(value);
                            if (isNaN(uid)) {
                                uid = null;
                            }
                        }
                    }
                    
                    // Check uid.
                    if (uid == null) {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."}});
                    }

                    // Verify.
                    if (await this.verify_2fa(uid, params["2fa"])) {
                        
                        // Set activated.
                        await this.set_activated(uid, true);
                        
                        // Response.
                        await this._create_user_cookie(response, uid);
                        return response.success({data: {message: "Successfully verified the 2FA code."}});
                    }
                    
                    // Invalid code.
                    else {
                        return response.error({status: Status.forbidden, data: {
                            error: "Permission denied.",
                            invalid_fields: {
                                "2fa": "Invalid code"
                            },
                        }});
                    }
                }
            },
        
            // Forgot password.
            {
                method: "POST",
                endpoint: "/vweb/auth/forgot_password",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    email: "string",
                    "2fa": "string",
                    password: "string",
                    verify_password: "string",
                },
                callback: async (request, response, params) => {
                    
                    // Verify password.
                    const error = this._verify_new_pass(params.password, params.verify_password);
                    if (error) {
                        return response.error({status: Status.bad_request, data: {error: error}});
                    }
                    
                    // Get uid.
                    let uid;
                    if ((uid = await this.get_uid_by_email(params.email)) == null) {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."},});
                    }
                    
                    // Verify 2fa.
                    if (await this.verify_2fa(uid, params["2fa"]) !== true) {
                        return response.error({status: Status.forbidden, data: {
                            error: "Invalid 2FA code.",
                            invalid_fields: {
                                "2fa": "Invalid code"
                            },
                        }});
                    }
                    
                    // Set password.
                    await this.set_password(uid, params.password);
                    
                    // Sign in.
                    return await this._sign_in_response(response, uid);
                }
            },
        )
        
        // ---------------------------------------------------------
        // Default user endpoints.

        this.endpoint(
        
            // Get user.
            {
                method: "GET",
                endpoint: "/vweb/user",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    detailed: {type: "boolean", default: false},
                },
                callback: async (request, response, params) => {
                    const user = await this.get_user(request.uid, params.detailed);
                    return response.success({data: user});
                }
            },

            // Set user.
            {
                method: "POST",
                endpoint: "/vweb/user",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    await this.set_user(request.uid, request.params);
                    await this._create_detailed_user_cookie(response, request.uid);
                    return response.success({data: {message: "Successfully updated your account."}});
                }
            },
        
            // Change password.
            {
                method: "POST",
                endpoint: "/vweb/user/change_password",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    current_password: "string",
                    password: "string",
                    verify_password: "string",
                },
                callback: async (request, response, params) => {
                    
                    // Verify old password.
                    if (await this.verify_password(request.uid, params.current_password) !== true) {
                        return response.error({
                            status: Status.unauthorized,
                            data: {error: "Incorrect password."},
                        });
                    }
                    
                    // Verify new password.
                    const error = this._verify_new_pass(params.password, params.verify_password);
                    if (error) {
                        return response.error({
                            status: Status.bad_request,
                            data: {error: error},
                        });
                    }
                    
                    // Set password.
                    await this.set_password(request.uid, pass);
                    
                    // Success.
                    return response.success({
                        status: Status.success,
                        data: {message: "Successfully updated your password."},
                    });
                }
            },

            // Delete account.
            {
                method: "DELETE",
                endpoint: "/vweb/user",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Set password.
                    await this.delete_user(request.uid);
                    
                    // Success.
                    return response.success({
                        status: Status.success,
                        data: {message: "Successfully deleted your account."},
                    });
                }
            },
        
            // Generate api key.
            {
                method: "POST",
                endpoint: "/vweb/user/api_key",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    return response.success({
                        data: {
                            "message": "Successfully generated an API key.",
                            "api_key": await this.generate_api_key(request.uid),
                        }
                    });
                }
            },
        
            // Revoke api key.
            {
                method: "DELETE",
                endpoint: "/vweb/user/api_key",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    await this.revoke_api_key(request.uid);
                    return response.send({
                        status: Status.success,
                        data: {message: "Successfully revoked your API key."},
                    });
                }
            },
            
            // Load data.
            {
                method: "GET",
                endpoint: "/vweb/user/data",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    path: "string",
                    default: {type: "string", default: null},
                },
                callback: async (request, response, params) => {
                    return response.send({
                        status: Status.success,
                        data: await this.load_user_data(request.uid, params.path, params.default)
                    });
                }
            },
        
            // Save data.
            {
                method: "POST",
                endpoint: "/vweb/user/data",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    path: "string",
                    data: {type: undefined},
                },
                callback: async (request, response, params) => {
                    await this.save_user_data(request.uid, params.path, params.data);
                    return response.send({
                        status: Status.success,
                        data: {message: "Successfully saved."},
                    });
                }
            },

            // Load proteced data.
            {
                method: "GET",
                endpoint: "/vweb/user/data/protected",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                params: {
                    path: "string",
                    default: {type: "string", default: null},
                },
                callback: async (request, response, params) => {
                    return response.send({
                        status: Status.success,
                        data: await this.load_protected_user_data(request.uid, params.path, params.default)
                    });
                }
            },
        )

        // ---------------------------------------------------------
        // Default support endpoints.

        this.endpoint(

            // Get PIN.
            {
                method: "GET",
                endpoint: "/vweb/support/pin",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {

                    // Sign in.
                    return response.success({data: {
                        message: "Successfully retrieved your support PIN.",
                        pin: await this.get_support_pin(request.uid),
                    }});
                }
            },

            // Support.
            // Supported params are: `support_pin`, `subject`, `summary`, `detailed`, `attachments`, `recipient` and `type`.
            {
                method: "POST",
                endpoint: "/vweb/support/submit",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Get params.
                    let params = request.params;

                    // When unauthenticated get contact params.
                    let user = null, email, first_name, last_name;
                    if (request.uid == null) {
                        try {
                            email = request.param("email");
                            first_name = request.param("first_name");
                            last_name = request.param("last_name");
                        } catch (err) {
                            return response.error({status: Status.bad_request, data: {error: err.message}});
                        }
                    } else {
                        this._check_uid_within_range(request.uid);
                        user = await this.get_user(request.uid);
                        email = user.email;
                        first_name = user.first_name;
                        last_name = user.last_name;
                    }

                    // Create mail body.
                    let body = "";
                    const subject = params.subject || (params.type == null ? "Support" : `Support ${params.type}`);
                    body += `<h1>${subject}</h1>`;
                    if (params.subject) {
                        delete params.subject;
                    }
                    if (params.type) {
                        body += `<span style='font-weight: bold'>Type</span>: ${params.type}<br>`;
                        delete params.type;
                    }
                    if (user) {
                        body += `<span style='font-weight: bold'>UID</span>: ${request.uid}<br>`;
                        body += `<span style='font-weight: bold'>User</span>: ${user.username}<br>`;
                    }
                    body += `<span style='font-weight: bold'>Email</span>: ${email}<br>`;
                    body += `<span style='font-weight: bold'>First Name</span>: ${first_name}<br>`;
                    body += `<span style='font-weight: bold'>Last Name</span>: ${last_name}<br>`;
                    if (request.uid != null) {
                        const support_pin = await this.get_support_pin(request.uid);
                        body += `<span style='font-weight: bold'>Support PIN</span>: ${support_pin} <span style='color: green'>verified</span><br>`;
                    } else if (params.support_pin) {
                        body += `<span style='font-weight: bold'>Support PIN</span>: ${params.support_pin} <span style='color: red'>not yet verified</span><br>`;
                        delete params.support_pin;
                    } else {
                        body += `<span style='font-weight: bold'>Support PIN</span>: Unknown<br>`;
                    }
                    if (params.summary) {
                        body += `<br><span style='font-weight: bold'>Summary</span>:<br>${params.summary}<br>`;
                        delete params.summary;
                    }
                    if (params.detailed) {
                        body += `<br><span style='font-weight: bold'>Detailed</span>:<br>${params.detailed}<br>`;
                        delete params.detailed;
                    }
                    Object.keys(params).iterate((key) => {
                        if (key !== "attachments" && key !== "recipient") {
                            body += `<br><span style='font-weight: bold'>${key}</span>: ${params[key]}<br>`;
                        }
                    })

                    // Attachments.
                    body += "<br>";
                    let attachments = null;
                    if (params.attachments) {
                        attachments = [];
                        Object.keys(params.attachments).iterate((key) => {
                            attachments.append({
                                filename: key,
                                content: Buffer.from(params.attachments[key], 'utf-8'),
                            })
                        })
                    }
                    
                    // Send email.
                    await this.send_mail({
                        recipients: [params.recipient || this.smtp_sender],
                        subject: subject,
                        body: body,
                        attachments: attachments,
                    })

                    // Sign in.
                    return response.success({data: {message: "Successfully sent your request."}});
                }
            },
        )
        
        // ---------------------------------------------------------
        // Payments endpoints.

        // Handler.
        return additional_file_watcher_paths;
    }

    // Create the sitemap endpoint.
    _create_sitemap() {
        let sitemap = "";
        sitemap += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        sitemap += "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n";
        this.endpoints.iterate((endpoint) => {
            if (
                endpoint.data == null &&
                endpoint.callback == null &&
                endpoint.endpoint != "robots.txt" &&
                !endpoint.authenticated
            ) {
                sitemap += `<url>\n   <loc>${new vlib.Path(this.full_domain).join(endpoint.endpoint).str()}</loc>\n</url>\n`;
            }
        })
        sitemap += "</urlset>\n";
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/sitemap.xml",
            data: sitemap,
            content_type: "application/xml",
            compress: false,
        }))
    }

    // Create the robots.txt endpoint.
    _create_robots_txt() {
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/robots.txt",
            content_type: "text/plain",
            data: `User-agent: *\nDisallow: \n\nSitemap: /sitemap.xml`,
            compress: false,
        }))
    }

    // ---------------------------------------------------------
    // Server (private).

    // Initialize.
    async _initialize() {

        // Check & create database.
        if (this.database.exists()) {
            this.database.mkdir_sync();
        }
        [
            ".sys",
            ".sys/users",
            ".sys/tokens",
            ".sys/usernames",
            ".sys/emails",
            ".sys/keys",
            ".sys/unactivated",
            ".sys/2fa",
            ".sys/support_pin",
            "users",
        ].iterate((subpath) => {
            this.database.join(subpath).mkdir_sync();
        })
        
        // Load keys.
        const path = this.database.join(".sys/keys/keys");
        if (!path.exists()) {
            this.hash_key = this._sys_generate_crypto_key(32);
            path.save_sync(JSON.stringify({
                sha256: this.hash_key,
            }));
        } else {
            const data = JSON.parse(path.load_sync());
            this.hash_key = data["sha256"];
            if (this.hash_key === undefined) {
                this.hash_key = this._sys_generate_crypto_key(32);
                data["sha256"] = this.hash_key;
                path.save_sync(JSON.stringify(data));
            }
        }
        
        // Get max user id.
        this.max_uid = 0;
        await this._iter_db_dir(".sys/users", (path) => {
            const uid = parseInt(path.name());
            if (uid > this.max_uid) {
                this.max_uid = uid;
            }
        });

        // Create default endpoints.
        this._create_default_endpoints();

        // Create static endpoints.
        this.statics.iterate((path) => {
            this._create_static_endpoints(path.base(), path);
        });
        
        // Create sitemap when it does not exist.
        if (this._find_endpoint("sitemap.xml") == null) {
            this._create_sitemap();
        }
        
        // Create robots.txt when it does not exist.
        if (this._find_endpoint("robots.txt") == null) {
            this._create_robots_txt();
        }

        // Set the caching of all endpoints.
        this.endpoints.iterate((endpoint) => {
            if (endpoint.callback === null) {
                if (this.production && endpoint.cache == null) {
                    endpoint.cache = 3600 * 24;
                } else if (!this.production) {
                    endpoint.cache = null;
                }
            }
        })
        
        // Payments.
        if (this.payments !== undefined) {
            await this.payments._initialize();
        }

        // Initialize default headers.
        this._initialize_default_headers();

        // Get the icon and stroke icon file paths when defined.
        this.company.stroke_icon_path = null;
        this.company.icon_path = null;
        if (this.company.stroke_icon || this.company.icon) {
            this.endpoints.iterate((endpoint) => {
                if (endpoint.endpoint === this.company.stroke_icon) {
                    this.company.stroke_icon_path = endpoint._path;
                }
                if (endpoint.endpoint === this.company.icon) {
                    this.company.icon_path = endpoint._path;
                }
            });
            if (this.company.stroke_icon != null && this.company.stroke_icon_path == null) {
                throw Error(`Unable to find the company's stroke icon endpoint "${this.company.stroke_icon}".`);
            }
            if (this.company.icon != null && this.company.icon_path == null) {
                throw Error(`Unable to find the company's icon endpoint "${this.company.icon}".`);
            }
        }
    }

    // Serve a client.
    // @todo implement rate limiting.
    async _serve(request, response) {
        return new Promise(async (resolve) => {

            // Log endpoint result.
            const log_endpoint_result = (message = null, status = null) => {
                utils.log(`${method}:${endpoint_url}: ${message === null ? response.status_message : message} [${status === null ? response.status_code : status}] (${request.ip}).`);
            }

            // Initialize the request and wait till all the data has come in.
            request = new Request(request);
            await request.promise;

            // Parse the request parameters.
            try {
                request._parse_params();
            } catch (err) {
                response.send({
                    status: 400, 
                    headers: {"Content-Type": "text/plain"},
                    data: `Bad Request - ${err}`,
                });
                log_endpoint_result();
                return resolve();
            }

            // Initialize the response.
            response = new Response(response);

            // Set default headers.
            this._set_header_defaults(response);

            // Check if the request matches any of the defined endpoints
            const method = request.method;
            const endpoint_url = request.endpoint;
            const endpoint = this.endpoints.find((endpoint) => {
                return endpoint.method === method && endpoint.endpoint === endpoint_url;
            });

            // No endpoint found.
            if (!endpoint) {
                response.send({
                    status: 404, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Not Found",
                });
                log_endpoint_result();
                return resolve();
            }

            // Check rate limiting.
            // @todo.

            // Always perform authentication so the request.uid will also be assigned even when the endpoint is not authenticated.
            const auth_result = await this._authenticate(request);

            // Reset cookies when authentication has failed, so the UserID cookies etc will be reset.
            if (auth_result !== null) {
                this._reset_cookies(response);
            }

            // When the endpoint is authenticated and the authentication has failed then send the error response.
            if (auth_result !== null && endpoint.authenticated) {
                response.send(auth_result);
                log_endpoint_result();
                return resolve();
            }

            // Serve endpoint.
            try {
                await endpoint._serve(request, response);
            } catch (err) {
                utils.error(`${endpoint.method}:${endpoint.endpoint}: `, err);
                response.send({
                    status: 500, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Internal Server Error",
                });
                log_endpoint_result();
                return resolve();
            }

            // Check if the response has been sent.
            if (!response.finished) {
                utils.error(`${endpoint.method}:${endpoint.endpoint}: `, "Unfinished response.");
                response.send({
                    status: 500, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Internal Server Error",
                });
                log_endpoint_result();
                return resolve();
            }

            // Log.
            log_endpoint_result();
            return resolve();
        })
    }

    // ---------------------------------------------------------
    // Server.

    // Start the server.
	/*  @docs {
     *  @title: Start
     *  @description:
     *      Start the server.
     *  @usage:
     *      ...
     *      server.start();
     */
    async start() {

        // Inside file watcher process.
        if (this.https === undefined && this.http === undefined) {
            return null;
        }

        // Initialize.
        await this._initialize();

        // Set default port.
        let http_port, https_port
        if (this.port == null) {
            http_port = 80;
            https_port = 443;
        } else {
            http_port = this.port;
            https_port = this.port + 1;
        }

        // Callbacks.
        let is_running = false;
        const on_running = () => {
            if (!is_running) {
                is_running = true;
                if (this.https !== undefined) {
                    utils.log(`Running on http://${this.ip}:${http_port} and https://${this.ip}:${https_port}.`); // @warning if you change this running on text you should update vide::BuildSystem since that depends on this log line.
                } else {
                    utils.log(`Running on http://${this.ip}:${http_port}.`); // @warning if you change this running on text you should update vide::BuildSystem since that depends on this log line.
                }
            }
        }
        const on_error = (error) => {
            if (error.syscall !== 'listen') {
                throw error; // This is a system error, not related to server listening
            }
            switch (error.code) {
                case 'EACCES':
                    console.error(`Error: Address ${this.ip}:${this.port} requires elevated privileges.`);
                    process.exit(1);
                    break;
                case 'EADDRINUSE':
                    console.error(`Error: Address ${this.ip}:${this.port} is already in use.`);
                    process.exit(1);
                    break;
                default:
                    throw error;
            }
        }

        // Listen.
        this.http.listen(http_port, this.ip, on_running);
        this.http.on("error", on_error);
        if (this.https !== undefined) {
            this.https.listen(https_port, this.ip, on_running);
            this.https.on("error", on_error);
        }

        // Set signals.
        process.on('SIGTERM', () => process.exit(0)); // the "this.https.close()" handler does not always get executed when run from vide build system, so use "process.exit()" instead.
        process.on('SIGINT', () => process.exit(0));
    }

    // Stop the server and exit the program.
	/*  @docs {
     *  @title: Stop
     *  @description:
     *      Stop the server and exit the program by default.
     *  @parameter:
     *      @name: exit
     *      @description: A boolean indicating whether the program should exit after stopping the server.
     *      @type: boolean
     *  @usage:
     *      ...
     *      server.stop();
     */
    stop(exit = true) {
        if (this.https === undefined && this.http === undefined) {
            return null; // inside file watcher process.
        }
        if (this.https !== undefined) {
            this.https.close((code) => { 
				if (exit) {
                	process.exit(0);
				}
            });
        }
        this.http.close((code) => { 
			if (exit) {
            	process.exit(0);
			}
        });
    }

    // Add a csp.
    /*  @docs:
     *  @title: Add CSP
     *  @description: Add an url to the Content-Security-Policy. This function does not overwrite the existing key's value.
     *  @warning: This function no longer has any effect when `Server.start()` has been called.
     *  @parameter:
     *      @name: key
     *      @description: The Content-Security-Policy key, e.g. `script-src`.
     *      @type: string
     *  @parameter:
     *      @name: value
     *      @description: The value to add to the Content-Security-Policy key.
     *      @type: null, string
     *  @usage:
     *      ...
     *      server.add_csp("script-src", "somewebsite.com");
     *      server.add_csp("upgrade-insecure-requests");
     */
    add_csp(key, value = null) {
        if (this.csp[key] === undefined) {
            this.csp[key] = "";
        }
        if (typeof value === "string" && value.length > 0) {
            this.csp[key] += " " + value.trim();
        }
    }

    // Remove a csp.
    /*  @docs:
     *  @title: Remove CSP
     *  @description: Remove an url from the Content-Security-Policy. This function does not overwrite the existing key's value.
     *  @warning: This function no longer has any effect when `Server.start()` has been called.
     *  @parameter:
     *      @name: key
     *      @description: The Content-Security-Policy key, e.g. `script-src`.
     *      @type: string
     *  @parameter:
     *      @name: value
     *      @description: The value to remove from the Content-Security-Policy key.
     *      @type: null, string
     *  @usage:
     *      ...
     *      server.remove_csp("script-src", "somewebsite.com");
     *      server.remove_csp("upgrade-insecure-requests");
     */
    remove_csp(key, value = null) {
        if (this.csp[option] === undefined) {
            return;
        }
        if (typeof value === "string" && value.length > 0) {
            this.csp[key] = this.csp[key].replaceAll(value, "");
        } else {
            delete this.csp[key];
        }
    }

    // Delete a csp key.
    /*  @docs:
     *  @title: Delete CSP
     *  @description: Delete an key from the Content-Security-Policy.
     *  @warning: This function no longer has any effect when `Server.start()` has been called.
     *  @parameter:
     *      @name: key
     *      @description: The Content-Security-Policy key, e.g. `script-src`.
     *      @type: string
     *  @usage:
     *      ...
     *      server.del_csp("script-src");
     *      server.del_csp("upgrade-insecure-requests");
     */
    del_csp(key) {
        delete this.csp[key];
    }

    // ---------------------------------------------------------
    // Endpoints.

    // Add one or multiple endpoints.
    /*  @docs:
        @title: Add endpoint(s)
        @description: Add one or multiple endpoints.
        @parameter: {
            @name: ...endpoints
            @description:
                The endpoint parameters.

                An endpoint parameter can either be a `Endpoint` class or an `object` with the `Endpoint` arguments.
            @type: Endpoint, object
        }
        */
    endpoint(...endpoints) {
        for (let i = 0; i < endpoints.length; i++) {
            let endpoint = endpoints[i];

            // Initialize endpoint.
            if (endpoint instanceof Endpoint === false) {
                endpoint = new Endpoint(endpoint)
            }

            // Build view.
            if (endpoint.view != null) {
                if (endpoint.view.meta == null) {
                    endpoint.view.meta = this.meta.copy();
                } else if (typeof endpoint.view.meta === "object" && endpoint.view.meta instanceof Meta === false) {
                    endpoint.view.meta = new Meta(endpoint.view.meta);
                }
                endpoint.view._build_html(this);
            }

            // Add endpoint.
            this.endpoints.push(endpoint);
        }
        return this;
    }

    // ---------------------------------------------------------
    // Users.
    
    // Check if a username exists.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Username Exists
     *  @description: Check if a username exists.
	 *  @type: boolean
     *  @return: Returns a boolean indicating whether the username exists or not.
     *  @parameter:
     *      @name: username
     *      @description: The username to check.
     *      @type: string
     *  @usage:
     *      ...
     *      const exists = await server.username_exists("someusername");
     */
    async username_exists(username) {
        return this.database.join(`.sys/usernames/${username}`, false).exists();
    }
    
    // Check if an email exists.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Email Exists
     *  @description: Check if a email exists.
	 *  @type: boolean
     *  @return: Returns a boolean indicating whether the email exists or not.
     *  @parameter:
     *      @name: email
     *      @description: The email to check.
     *      @type: string
     *  @usage:
     *      ...
     *      const exists = await server.email_exists("some\@email.com");
     */
    async email_exists(email) {
        return this.database.join(`.sys/emails/${email}`, false).exists();
    }
    
    // Check if a user account is activated.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Is Activated
     *  @description: Check if a user account is activated.
     *  @return: Returns a boolean indicating whether the account is activated or not.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the account to check.
     *      @type: number
     *  @usage:
     *      ...
     *      const activated = await server.is_activated(0);
     */
    async is_activated(uid) {
        return !this.database.join(`.sys/unactivated/${uid}`, false).exists();
    }
    
    // Set the activated status of a user account is activated.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Set Activated
     *  @description: Set the activated status of a user account is activated.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the account.
     *      @type: number
     *  @parameter:
     *      @name: activated
     *      @description: The boolean with the new activated status.
     *      @type: boolean
     *  @usage:
     *      ...
     *      await server.set_activated(1, true);
     */
    async set_activated(uid, activated) {
        const path = this.database.join(`.sys/unactivated/${uid}`, false);
        if (activated == true) {
            path.del_sync();
        } else {
            path.save_sync("");
        }
    }
    
    // Create user.
    /*  @docs:
     *  @title: Create User
     *  @description: 
     *      Create a user account.
     *
     *      Only the hashed password will be saved.
     *  @return: Returns the uid of the newly created user.
     *  @parameter:
     *      @name: first_name
     *      @description: The user's first name.
     *      @type: string
     *      @required: true
     *  @parameter:
     *      @name: last_name
     *      @description: The user's last name.
     *      @type: string
     *      @required: true
     *  @parameter:
     *      @name: username
     *      @description: The username of the new account.
     *      @type: string
     *      @required: true
     *  @parameter:
     *      @name: email
     *      @description: The email of the new account.
     *      @type: string
     *      @required: true
     *  @parameter:
     *      @name: password
     *      @description: The password of the new account.
     *      @type: string
     *      @required: true
     *  @parameter:
     *      @name: phone_number
     *      @description: The phone number of the user account.
     *      @type: string
     *  @usage:
     *      ...
     *      const uid = await server.create_user({
     *          first_name: "John", 
     *          last_name: "Doe", 
     *          username: "johndoe", 
     *          email: "johndoe\@email.com",
     *          password: "HelloWorld!"
     *      });
     */
    async create_user({
        first_name,
        last_name,
        username,
        email,
        password,
        phone_number = "",
    }) {
        
        // Check if username & email already exist.
        if (await this.username_exists(username)) {
            const e = new Error(`Username "${username}" is already registered.`);
            e.invalid_fields = {"username": "Username is already registered"};
            throw e;
        }
        if (await this.email_exists(email)) {
            const e = new Error(`Email "${email}" is already registered.`);
            e.invalid_fields = {"email": "Email is already registered"};
            throw e;
        }
        
        // Get new uid.
        // @todo check for deleted uids.
        await this.edit_max_uid_mutex.lock();
        ++this.max_uid;
        const uid = this.max_uid;
        this.edit_max_uid_mutex.unlock();
        
        // Save sys data.
        this._sys_save_user(uid, {
            first_name: first_name,
            last_name: last_name,
            username: username,
            email: email,
            password: this._hmac(password),
            api_key: "",
            phone_number: phone_number,
        });
        this._sys_save_uid_by_username(uid, username);
        this._sys_save_uid_by_email(uid, email);
        if (this.enable_account_activation) {
            await this.set_activated(uid, false);
        }
        
        // Create user dir.
        this.database.join(`/users/${uid}/`).mkdir_sync();
        this.database.join(`/users/${uid}/private`).mkdir_sync();
        this.database.join(`/users/${uid}/protected`).mkdir_sync();
        this.database.join(`/users/${uid}/public`).mkdir_sync();
        
        // Return uid.
        return uid;
    }
    
    // Delete user.
    // The file paths should never be deleted.
    /*  @docs:
     *  @title: Delete User
     *  @description: Delete a user account.
     *  @parameter:
     *      @name: uid
     *      @description: The user id of the account to delete.
     *      @type: number
     *  @usage:
     *      ...
     *      await server.delete_user(0);
     */
    async delete_user(uid) {
        this._check_uid_within_range(uid);
        this._sys_delete_user(uid);
    }
    
    // Set a user's first name.
    /*  @docs:
     *  @title: Set First Name
     *  @description:
     *      Set a user's first name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: first_name
     *      @description: The new first name.
     *      @type: string
     *  @usage:
     *      ...
     *      await server.set_first_name(1, "John");
     */
    async set_first_name(uid, first_name) {
        const user = await this.get_user(uid);
        user.first_name = first_name;
        this._sys_save_user(uid, user);
    }
    
    // Set a user's last name.
    /*  @docs:
     *  @title: Set Last Name
     *  @description:
     *      Set a user's last name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: last_name
     *      @description: The new last name.
     *      @type: string
     *  @usage:
     *      ...
     *      await server.set_last_name(1, "Doe");
     */
    async set_last_name(uid, last_name) {
        const user = await this.get_user(uid);
        user.last_name = last_name;
        this._sys_save_user(uid, user);
    }
    
    // Set a user's username.
    /*  @docs:
     *  @title: Set Username
     *  @description:
     *      Set a user's username
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: username
     *      @description: The new username.
     *      @type: string
     *  @usage:
     *      ...
     *      await server.set_username(1, "newusername");
     */
    async set_username(uid, username) {
        if (await this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        const user = await this.get_user(uid);
        user.username = username;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_username(uid, username);
    }
    
    // Set a user's email.
    /*  @docs:
     *  @title: Set Email
     *  @description:
     *      Set a user's email
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: email
     *      @description: The new email.
     *      @type: string
     *  @usage:
     *      ...
     *      await server.set_email(1, "new\@email.com");
     */
    async set_email(uid, email) {
        if (await this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        const user = await this.get_user(uid);
        user.email = email;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_email(uid, email);
    }
    
    // Set a user's password.
    /*  @docs:
     *  @title: Set Password
     *  @description:
     *      Set a user's password
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: password
     *      @description: The new password.
     *      @type: string
     *  @usage:
     *      ...
     *      await server.set_password(1, "XXXXXX");
     */
    async set_password(uid, password) {
        const user = await this.get_user(uid);
        user.password = this._hmac(password);
        this._sys_save_user(uid, user);
    }
    
    // Set a user's data.
    /*  @docs:
     *  @title: Set user
     *  @description:
     *      Set a user's data
     *
     *      When a key does not exist in the new user object it will not be set.
     *
     *      Does not update the user's id, key and password data.
     *      If the uid does not exist an `Error` will be thrown.
     *
     *      The user object may include additional data which will be saved as the user's detailed data.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: user
     *      @description: The new user object.
     *      @type: object
     *  @parameter:
     *      @name: user
     *      @description: The new user object.
     *      @type: object
     *  @usage:
     *      ...
     *      await server.set_user(1, {first_name: "John", last_name: "Doe"});
     */
    async set_user(uid, user) {
        const current_user = await this.get_user(uid);
        let old_username = null, old_email = null;
        
        // First name.
        if (user.first_name != null && user.first_name != current_user.first_name) {
            current_user.first_name = user.first_name;
        }
        
        // Last name.
        if (user.last_name != null && user.last_name != current_user.last_name) {
            current_user.last_name = user.last_name;
        }
        
        // Username.
        if (user.username != null && user.username != current_user.username) {
            if (await this.username_exists(user.username)) {
                throw Error(`Username "${user.username}" already exists.`);
            }
            old_username = current_user.username;
            current_user.username = user.username;
        }
        
        // Email.
        if (user.email != null && user.email != current_user.email) {
            if (await this.email_exists(user.email)) {
                throw Error(`Email "${user.email}" already exists.`);
            }
            old_email = current_user.email;
            current_user.email = user.email;
        }
        
        // Save.
        this._sys_save_user(uid, current_user);
        if (old_username !== null) {
            this._sys_save_uid_by_username(uid, current_user.username);
            this._sys_delete_uid_by_username(uid, old_username);
        }
        if (old_email !== null) {
            this._sys_save_uid_by_email(uid, current_user.email);
            this._sys_delete_uid_by_email(uid, old_email);
        }

        // Check if the item contains more than default data.
        const keys = Object.keys(current_user);
        if (keys.length > 8) {
            const detailed = {};
            for (let k = 0; k < keys.length; k++) {
                switch (keys[k]) {
                    case "uid":
                    case "first_name":
                    case "last_name":
                    case "username":
                    case "email":
                    case "password":
                    case "api_key":
                    case "phone_number":
                        break;
                    default:
                        detailed[keys[k]] = current_user[keys[k]];
                        break;
                }
            }
            this._sys_save_detailed_user(uid, detailed);
        }
    }
    
    // Get uid by username.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get UID
     *  @description: Get a uid by username.
     *  @return:
     *      Returns the uid of the username.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter:
     *      @name: username
     *      @description: The username of the uid to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid("myusername")) !== null) { ... }
     */
    async get_uid(username) {
        if (username == null || username === "") {
            return null;
        }
        const path = this.database.join(`.sys/usernames/${username}`, false);
        if (path.exists()) {
            const uid = parseInt(path.load_sync());
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by email.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get UID By Email
     *  @description: Get a uid by email.
     *  @return:
     *      Returns the uid of the email.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter:
     *      @name: email
     *      @description: The email of the uid to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid_by_email("my\@email.com")) !== null) { ... }
     */
    async get_uid_by_email(email) {
        if (email == null || email === "") {
            return null;
        }
        const path = this.database.join(`.sys/emails/${email}`, false);
        if (path.exists()) {
            const uid = parseInt(path.load_sync());
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by api key.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get UID By API Key
     *  @description: Get a uid by API key.
     *  @return:
     *      Returns the uid of the api key.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter:
     *      @name: api_key
     *      @description: The API key of the uid to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid_by_api_key("XXXXXXXXXX")) !== null) { ... }
     */
    async get_uid_by_api_key(api_key) {
        let pos;
        if ((pos = api_key.indexOf(':')) != -1) {
            const uid = parseInt(api_key.substr(1, pos - 1));
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by token.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get UID By Token
     *  @description: Get a uid by token.
     *  @return:
     *      Returns the uid of the token.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter:
     *      @name: token
     *      @description: The token of the uid to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid_by_token("XXXXXXXXXX")) !== null) { ... }
     */
    async get_uid_by_token(token) {
        return await this.get_uid_by_api_key(token);
    }
    
    // Get user info by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get User
     *  @description:
     *      Get a user by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user to fetch.
     *      @type: number
     *  @parameter:
     *      @name: detailed
     *      @description: Also retrieve the detailed user data.
     *      @type: boolean
     *  @usage:
     *      ...
     *      const user = await server.get_user(0);
     */
    async get_user(uid, detailed = false) {
        this._check_uid_within_range(uid);
        let data = this._sys_load_user(uid);
        if (detailed) {
            data = {...this._sys_load_detailed_user(uid), ...data};
        }
        return data;
    }
    
    // Get user info by username.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get User By Username
     *  @description:
     *      Get a user by username.
     *
     *      If the username does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter:
     *      @name: username
     *      @description: The username of the user to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_username("myusername");
     */
    async get_user_by_username(username) {
        const uid = await this.get_uid(username);
        if (uid === null) {
            throw Error(`No user with username "${username}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Get user info by email.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get User By Email
     *  @description:
     *      Get a user by email.
     *
     *      If the email does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter:
     *      @name: email
     *      @description: The email of the user to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_email("my\@email.com");
     */
    async get_user_by_email(email) {
        const uid = await this.get_uid_by_email(email);
        if (uid === null) {
            throw Error(`No user with email "${email}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Get user info by api key.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get User By API Key
     *  @description:
     *      Get a user by API key.
     *
     *      If the API key does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter:
     *      @name: api_key
     *      @description: The API key of the user to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_api_key("XXXXXX");
     */
    async get_user_by_api_key(api_key) {
        const uid = await this.get_uid_by_api_key(api_key);
        if (uid === null) {
            throw Error(`No user with api key "${api_key}" exists.`);
        }
        return await this.get_user(uid);
    }

    // Get a user's support pin by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get Support PIN
     *  @description:
     *      Get a user's support pin by uid.
     *  @return:
     *      Returns a User object.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @usage:
     *      ...
     *      const pin = await server.get_support_pin(1);
     */
    async get_support_pin(uid) {
        this._check_uid_within_range(uid);
        const path = this.database.join(`.sys/support_pin/${uid}`, false);
        if (path.exists()) {
            return path.load_sync();
        } else {
            const pin = this._sys_generate_2fa();
            path.save_sync(pin)
            return pin;
        }
        return await this.get_user(uid);
    }
    
    // Get user info by token.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Get User By Token
     *  @description:
     *      Get a user by token.
     *
     *      If the token does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter:
     *      @name: token
     *      @description: The token of the user to fetch.
     *      @type: string
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_token("XXXXXX");
     */
    async get_user_by_token(token) {
        const uid = await this.get_uid_by_token(token);
        if (uid === null) {
            throw Error(`No user with token "${token}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Load user data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Load Public User Data
     *  @description:
     *      Load public user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns the `def` parameter when the data does not exist, keep in mind that when parameter `def` is an object it could be a reference to a defined variable.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: def
     *      @description:
     *          The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *
     *          When the type of parameter `def` is `object` then the keys that do not exist in the loaded object, but do exist in the default object will be inserted into the loaded object.
     *      @type: boolean, number, string, array, object.
     *  @usage:
     *      ...
     *      const data = await server.load_user_data(1, "mydata", {});
     */
    async load_user_data(uid, subpath, def = null) {
        return this._sys_load_user_data(uid, subpath, def, "public");
    }
    
    // Save user data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Load Public User Data
     *  @description:
     *      Save user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  @usage:
     *      ...
     *      await server.save_user_data(1, "mydata", {"Hello": "World!"});
     *      await server.save_user_data(1, "mystring", "Hello World!");
     */
    async save_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._sys_save_user_data(uid, subpath, "public");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load user data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Load Protected User
     *  @description:
     *      Load protected user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns the `def` parameter when the data does not exist, keep in mind that when parameter `def` is an object it could be a reference to a defined variable.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: def
     *      @description:
     *          The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *
     *          When the type of parameter `def` is `object` then the keys that do not exist in the loaded object, but do exist in the default object will be inserted into the loaded object.
     *      @type: boolean, number, string, array, object.
     *  @usage:
     *      ...
     *      const data = await server.load_protected_user_data(1, "mydata", {});
     */
    async load_protected_user_data(uid, subpath, def = null) {
        return this._sys_load_user_data(uid, subpath, def, "protected");
    }
    
    // Save user data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Save Proteced User Data
     *  @description:
     *      Save protected user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  @usage:
     *      ...
     *      await server.save_protected_user_data(1, "mydata", {"Hello": "World!"});
     *      await server.save_protected_user_data(1, "mystring", "Hello World!");
     */
    async save_protected_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._sys_save_user_data(uid, subpath, "protected");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load user data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Load Private User Data
     *  @description:
     *      Load private user data by subpath.
     *
     *      The subpath resides in the user's private data directory.
     *
     *      The user has no read or write access to the private directory.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns the `def` parameter when the data does not exist, keep in mind that when parameter `def` is an object it could be a reference to a defined variable.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: def
     *      @description:
     *          The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *
     *          When the type of parameter `def` is `object` then the keys that do not exist in the loaded object, but do exist in the default object will be inserted into the loaded object.
     *      @type: boolean, number, string, array, object.
     *  @usage:
     *      ...
     *      const data = await server.load_private_user_data(1, "mydata", {});
     */
    async load_private_user_data(uid, subpath, def = null) {
        return this._sys_load_user_data(uid, subpath, def, "private");
    }
    
    // Save user data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Save Private User Data
     *  @description:
     *      Save private user data by subpath.
     *
     *      The subpath resides in the user's private data directory.
     *
     *      The user has no read or write access to the private directory.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  @usage:
     *      ...
     *      await server.save_private_user_data(1, "mydata", {"Hello": "World!"});
     *      await server.save_private_user_data(1, "mystring", "Hello World!");
     */
    async save_private_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._sys_save_user_data(uid, subpath, "private");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load system data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Load System Data
     *  @description:
     *      Load system data by subpath.
     *
     *      The subpath resides in the `{{database}}/sys/` directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns the `def` parameter when the data does not exist, keep in mind that when parameter `def` is an object it could be a reference to a defined variable.
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: def
     *      @description:
     *          The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *
     *          When the type of parameter `def` is `object` then the keys that do not exist in the loaded object, but do exist in the default object will be inserted into the loaded object.
     *      @type: boolean, number, string, array, object.
     *  @usage:
     *      ...
     *      const data = await server.load_sys_data("mydata", {});
     */
    async load_sys_data(subpath, def = null) {
        return this._sys_load_sys_data(subpath, def);
    }
    
    // Save system data.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Load System Data
     *  @description:
     *      Save system data by subpath.
     *
     *      The subpath resides in the `{{database}}/sys/` directory.
     *  @parameter:
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  @parameter:
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  @usage:
     *      ...
     *      await server.save_sys_data("mydata", {"Hello": "World!"});
     *      await server.save_sys_data("mystring", "Hello World!");
     */
    async save_sys_data(subpath, data) {

        // Initialize path.
        const path = this.database.join(`sys/${subpath}`, false);
        const base = path.base();
        if (base.exists() === false) {
            base.mkdir_sync();
        }

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }
    
    // Generate an api key by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Generate API Key
     *  @description:
     *      Generate an API key for a user.
     *
     *      Generating an API key overwrites all existing API keys.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns the API key string.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the account to generate an API key for.
     *      @type: number
     *  @usage:
     *      ...
     *      const api_key = await server.generate_api_key(0);
     */
    async generate_api_key(uid) {
        this._check_uid_within_range(uid);
        const api_key = `0${uid}:${this._sys_generate_key()}`;
        const user = this._sys_load_user(uid);
        user.api_key = this._hmac(api_key);
        this._sys_save_user(uid, user);
        return api_key;
    }
    
    // Revoke the API key of a user.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Revoke API Key
     *  @description:
     *      Revoke the API key of a user.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the account to revoke the API key for.
     *      @type: number
     *  @usage:
     *      ...
     *      await server.revoke_api_key(0);
     */
    async revoke_api_key(uid) {
        this._check_uid_within_range(uid);
        const user = this._sys_load_user(uid);
        user.api_key = "";
        this._sys_save_user(uid, user);
    }
    
    // Verify a plaintext password.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Verify Password
     *  @description:
     *      Verify a plaintext password.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the account to verify.
     *      @type: number
     *  @parameter:
     *      @name: password
     *      @description: The plaintext password.
     *      @type: string
     *  @usage:
     *      ...
     *      const success = await server.verify_password(1, "XXXXXX");
     */
    async verify_password(uid, password) {
        if (uid === null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.password === this._hmac(password);
    }
    
    // Verify a plaintext api key.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Verify API Key
     *  @description:
     *      Verify an plaintext API key.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter:
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  @usage:
     *      ...
     *      const success = await server.verify_api_key("XXXXXX");
     */
    async verify_api_key(api_key) {
        return await this.verify_api_key_by_uid(await this.get_uid_by_api_key(api_key), api_key);
    }

    // Verify a plaintext api key by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Verify API Key By UID
     *  @description:
     *      Verify an plaintext API key by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the api key to verify.
     *      @type: number
     *  @parameter:
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  @usage:
     *      ...
     *      const success = await server.verify_api_key_by_uid(1, "XXXXXX");
     */
    async verify_api_key_by_uid(uid, api_key) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.api_key.length > 0 && user.api_key == this._hmac(api_key);
    }
    
    // Verify a token.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Verify Token
     *  @description:
     *      Verify an plaintext token.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter:
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  @usage:
     *      ...
     *      const success = await server.verify_token("XXXXXX");
     */
    async verify_token(token) {
        return await this.verify_token_by_uid(await this.get_uid_by_api_key(token), token);
    }

    // Verify a token by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Verify Token By UID.
     *  @description:
     *      Verify an plaintext token by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the token to verify.
     *      @type: number
     *  @parameter:
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  @usage:
     *      ...
     *      const success = await server.verify_token_by_uid(1, "XXXXXX");
     */
    async verify_token_by_uid(uid, token) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const correct_token = this._sys_load_user_token(uid);
        return correct_token.token != null && Date.now() < correct_token.expiration && correct_token.token == this._hmac(token);
    }

    // Verify a 2fa code.
    // Use async to keep it persistent with other functions.
    /*  @docs:
     *  @title: Verify 2FA Code
     *  @description:
     *      Verify a 2FA code by user id.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: code
     *      @description: The 2FA code.
     *      @type: string
     *  @return: Returns a boolean indicating whether the verification was successful or not.
     *  @usage:
     *      ...
     *      await server.verify_2fa(1, "123456");
     */
    async verify_2fa(uid, code) {
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const auth = this._sys_load_user_2fa(uid);
        const now = Date.now();
        const status = auth.code != null && now < auth.expiration && auth.code == code;
        if (status || now > auth.expiration) {
            this._sys_delete_user_2fa(uid);
        }
        return status;
    }
    
    // Send a mail.
    /*  @docs:
     *  @title: Send Mail
     *  @description:
     *      Send one or multiple mails.
     *
     *      Make sure the domain's DNS records SPF and DKIM are properly configured when sending attachments.
     *
     *      See `vlib::smtp::Client` and `vlib::smtp::Mail` for more info.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the mail has been sent.
     *  @parameter:
     *      @name: sender
     *      @description:
     *          The sender address.
     *          A sender address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: string, array
     *  @parameter:
     *      @name: recipients
     *      @description:
     *          The recipient addresses.
     *          A reciepient address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: array[string, array]
     *  @parameter:
     *      @name: subject
     *      @description: The subject text.
     *      @type: string
     *  @parameter:
     *      @name: body
     *      @description: The body text.
     *      @type: string
     *  @parameter:
     *      @name: attachments
     *      @description: An array with absolute file paths for attachments, or an array with nodemailer attachment objects.
     *      @type: array[string], array[object]
     *  @usage:
     *      ...
     *      await server.send_mail({
     *          sender: ["Sender Name", "sender\@email.com"],
     *          recipients: [
     *              ["Recipient Name", "recipient1\@email.com"],
     *              "recipient2\@email.com",
     *          },
     *          subject: "Example Mail",
     *          body: "Hello World!",
     *          attachments: ["/path/to/image.png"]
     *      });
     */
    async send_mail({
        sender = null,
        recipients = [],
        subject = null,
        body = "",
        attachments = [],
    }) {
        // return new Promise(async (resolve, reject) => {

        // Not enabled.
        if (this.smtp === undefined) {
            return new Error("SMTP is not enabled, define the required server argument on initialization to enable smtp.");
        }

        // Convert MailElement to html.
        if (body instanceof Mail.MailElement) {
            body = body.html();
        }

        // Check args.
        if (sender === null) {
            sender = this.smtp_sender;
            // return new Error(`Parameter "sender" should be a defined value of type "string" or "array".`);
        }
        if (recipients.length === 0) {
            return new Error(`The mail has no recipients.`);
        }
        if (sender === null) {
            return new Error(`Parameter "sender" should be a defined value of type "string" or "array".`);
        }

        // Format address wrapper.
        const format_address = (address) => {
            if (Array.isArray(address)) {
                return `${address[0]} <${address[1]}>`;
            }
            return address;
        }

        // Create to array.
        const to = [];
        recipients.iterate((address) => to.push(format_address(address)));

        // Create attachments array.
        let attached_files = [];
        if (attachments != null) {
            if (attachments.length > 0 && typeof attachments[0] === "object") {
                attached_files = attachments;
            } else {
                attachments.iterate((path) => {
                    if (path instanceof vlib.Path) {
                        attached_files.push({
                            filename: path.name(),
                            path: path.str(),
                        })
                    } else {
                        attached_files.push({
                            filename: new vlib.Path(path).name(),
                            path: path,
                        })
                    }
                })
            }
        }

        // Send mail.
        try {
            return await this.smtp.sendMail({
                from: format_address(sender),
                to: to,
                subject: subject,
                html: body,
                attachments: attachments,
            });
        } catch (error) {
            throw new Error(error.message); // to keep readable stacktrace.
        }
            // try {
            //     this.smtp.sendMail(
            //         {
            //             from: format_address(sender),
            //             to: to,
            //             subject: subject,
            //             html: body,
            //             attachments: attachments,
            //         },
            //         (error, info) => {
            //             if (error) {
            //                 reject(new Error(error.message)); // to keep readable stacktrace.
            //             } else {
            //                 resolve(info);
            //             }
            //         }
            //     )
            // } catch (error) {
            //     reject(new Error(error.message)); // to keep readable stacktrace.
            // }

        // })
    }
    
    // Send a 2fa code.
    /*  @docs:
     *  @title: Send 2FA Code
     *  @description:
     *      Send a 2FA code to a user by user id.
     *
     *      By default the 2FA code will be valid for 5 minutes.
     *
     *      The mail body will be generated using the `on_2fa_mail({code, username, email, date, ip, device})` callback. When the callback is not defined an error will be thrown.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the 2fa mail has been sent.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: request
     *      @description: The request object from the client request.
     *      @type: object
     *  @parameter:
     *      @name: expiration
     *      @description: The amount of seconds in which the code will expire.
     *      @type: number
     *  @usage:
     *      ...
     *      await server.send_2fa({uid: 0, request: request});
     */
    async send_2fa({
        uid, 
        request,
        expiration = 300,
        _device = null,
    }) {
        this._check_uid_within_range(uid);
        
        // Generate 2fa.
        const auth = {
            expiration: Date.now() + expiration * 1000,
            code: this._sys_generate_2fa(),
        };
        this._sys_save_user_2fa(uid, auth);
        
        // Get user email.
        const user = await this.get_user(uid);
        
        // Get device.
        let device;
        if (_device === null) {
            device = request.headers["user-agent"];
        }
        
        // Replace body.
        if (this.on_2fa_mail === undefined) {
            throw Error("Define server callback \"on_2fa_mail\" to generate the HTML mail body.");
        }
        let body = this.on_2fa_mail({
            code: auth.code,
            username: user.username,
            email: user.email,
            date: new Date().toUTCString(),
            ip: request.ip,
            device: device ? device : "Unknown",
        });
        if (body instanceof Mail.MailElement) {
            body = body.html();
        }
        
        // Send mail.
        return await this.send_mail({
            sender: this.smtp_sender,
            recipients: [user.email],
            subject: "Two Factor Authentication Code",
            body: body,
        });   
    }

    // ---------------------------------------------------------
    // Default callbacks.
    // These can all be overwritten by the user.

    // On successfull one-time payment.
    // This gets called for every product in the payment.
    on_payment({product, payment}) {}

    // On successfull subscription.
    // This gets called for every product in the payment.
    on_subscription({product, payment}) {}

    // On failed one-time or recurring payment.
    on_failed_payment({payment}) {}

    // On successfull cancellation.
    on_cancellation({payment, line_items}) {}

    // On failed cancellation.
    on_failed_cancellation({payment, line_items}) {}

    // On successfull refund.
    // The line items array are the items were refunded.
    on_refund({payment, line_items}) {}

    // On failed refund.
    // The line items array are the items were the refund failed.
    on_failed_refund({payment, line_items}) {}

    // On chargeback.
    // The line items array are the items were charged back.
    on_chargeback({payment, line_items}) {}

    // On failed chargeback.
    // The line items array are the items were the chargeback failed.
    on_failed_chargeback({payment, line_items}) {}

    // Mail template.
    _mail_template({
        max_width = 400,
        children = [],
    }) {
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Create header.
        let header;
        if (this.company.stroke_icon != null) {
            header = [
                Image(`${this.full_domain}${this.company.stroke_icon}`)
                    .height(16),
            ]
        } else if (this.company.icon != null) {
            header = [
                Image(`${this.full_domain}${this.company.icon}`)
                    .frame(20, 40),
            ]
        }
        if (header) {
            header = Table(
                TableRow(...header)
                .wrap(true)
                .center()
                .center_vertical()
            )
            .margin_bottom(15);
        }

        // Create mail.
        return Mail.Mail(
            Table(
                TableData(
                    Table(
                    
                        // Header.
                        header,

                        // Widget.
                        Table(...children)
                        .background_color(style.widget_bg)
                        .border(`1px solid ${style.widget_border}`)
                        .border_radius("10px")
                        .padding(40, 25, 25, 25)
                        .margin(0),

                        // Copyright.
                        Table(
                            TableRow(
                                Text(
                                    `Copyright Â© ${new Date().getFullYear()} ${this.company.name}, ${this.company.legal_name} All Rights Included.\n` +
                                    `${this.company.street} ${this.company.house_number}, ${this.company.postal_code}, ${this.company.city}, ${this.company.province}, ${this.company.country}.\n` +
                                    (this.company.tax_id == null ? "" : `VAT ID ${this.company.tax_id}`)
                                )
                                .white_space("pre")
                                .display("inline-block")
                                .font_size(11)
                                .color(style.footer_fg)
                                .margin(0)
                            )
                            .center()
                            .center_vertical(),
                        )
                        .margin(0, 0, 10, 0)
                    )
                    .max_width(max_width)
                )
                .center()
            )
            .padding(25, 20, 25, 20)
        )
        .font_family(style.font)
        .background(style.bg)
    }

    // Render payment line items.
    _render_mail_payment_line_items({payment, line_items, show_total_due = false}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Render payment line item for a mail.
        const _render_mail_payment_line_item = ({name, desc, unit_cost, quantity, total_cost, font_weight = "normal", divider = true, color = style.text_fg}) => {
            return [
                Table(
                    TableRow(
                        TableData(
                            Text(name)
                                .color(color)
                                .font_size(14)
                                .text_wrap("wrap")
                                .overflow_wrap("break-word")
                                .word_wrap("break-word")
                                .font_weight(font_weight)
                        )
                        .width("25%")
                        .margin_right(10),
                        TableData(
                            Text(desc)
                                .color(color)
                                .font_size(14)
                                .text_wrap("wrap")
                                .overflow_wrap("break-word")
                                .word_wrap("break-word")
                                .font_weight(font_weight)
                        )
                        .width("35%")
                        .margin_right(10),
                        TableData(
                            Text(unit_cost)
                                .color(color)
                                .font_size(14)
                                .text_wrap("wrap")
                                .overflow_wrap("break-word")
                                .word_wrap("break-word")
                                .font_weight(font_weight)
                        )
                        .fixed_width("13.32%")
                        .margin_right(10),
                        TableData(
                            Text(quantity)
                                .color(color)
                                .font_size(14)
                                .text_wrap("wrap")
                                .overflow_wrap("break-word")
                                .word_wrap("break-word")
                                .font_weight(font_weight)
                        )
                        .fixed_width("13.32%")
                        .margin_right(10),
                        TableData(
                            Text(total_cost)
                                .color(color)
                                .font_size(14)
                                .text_wrap("wrap")
                                .overflow_wrap("break-word")
                                .word_wrap("break-word")
                                .font_weight(font_weight)
                        )
                        .fixed_width("13.32%"),
                    )
                    .width("100%")
                    .styles({"vertical-align": "baseline"}),
                )
                .width("100%"),

                !divider ? null : TableRow(
                    TableData(
                        VStack()
                            .background_color(style.text_fg)
                            .frame("100%", 1)
                            .margin(5, 0, 10, 0)
                    )
                    .frame("100%", 1)
                )
                .width("100%"),
            ];
        }

        // Render a dividier.
        const render_divider = () => {
            return TableRow(
                TableData(
                    VStack()
                        .background_color(style.divider_bg)
                        .frame("100%", 1)
                        .margin(5, 0, 10, 0)
                )
                .frame("100%", 1)
            )
            .width("100%")
        }

        // Vars.
        let currency = null;
        let subtotal = 0;
        let subtotal_tax = 0;
        let total = 0;
        payment.line_items.iterate((item) => {
            if (typeof item.product === "string") {
                item.product = this.payments.get_product_sync(item.product);
            }
            if (currency == null) {
                currency = utils.get_currency_symbol(item.product.currency);
            }
            subtotal += item.subtotal;
            subtotal_tax += item.tax;
            total += item.total;
        })
        let total_due = payment.status === "open" ? total : 0;

        return [
            render_divider(),
            line_items.iterate_append((item, index) => {
                console.log(item)
                return Table(
                    TableRow(
                        TableData(
                            Image(item.product.icon)
                            .frame(35, 35)
                            .margin_right(15),
                        )
                        .width("auto"),
                        TableData(
                            Table(
                                Text(item.product.name)
                                    .color(style.title_fg)
                                    .font_size(14)
                                    .font_weight("bold")
                                    .margin(0)
                                    .ellipsis_overflow(true),
                                Text(item.product.description)
                                    .color(style.text_fg)
                                    .font_size(14)
                                    .margin(0)
                                    .ellipsis_overflow(true)
                            )
                        )
                        .width("100%"),
                        TableData(
                            Text(`${currency} ${item.subtotal.toFixed(2)}`)
                                .color(style.title_fg)
                                .font_size(14)
                                .font_weight("bold")
                                .margin(0)
                                .white_space("nowrap")
                        )
                        .width("100%")
                    )
                    .wrap(true)
                    .leading_vertical()
                    .width("100%")
                )
                .width("100%")
            }),
            render_divider(),
            Table(
                [
                    ["Subtotal:", `${currency} ${subtotal.toFixed(2)}`],
                    ["Tax:", `${currency} ${subtotal_tax.toFixed(2)}`],
                    ["Total:", `${currency} ${total.toFixed(2)}`],
                ].iterate_append((item) => {
                    return TableRow(
                        TableData()
                            .width("100%"),
                        TableData(
                            Text(item[0])
                            .color(style.title_fg)
                            .font_size(14)
                            .ellipsis_overflow(true)
                            .font_weight("bold")
                        )
                        .min_width(75),
                        TableData(
                            Text(item[1])
                            .color(style.title_fg)
                            .font_size(14)
                            .white_space("nowrap")
                            .font_weight("bold"),
                        )
                        // .min_width(50)
                    )
                    .wrap(true)
                    // .text_align("right")
                }),
            ),

            // Line items.
            // _render_mail_payment_line_item({
            //     name: "Item",
            //     desc: "Description",
            //     unit_cost: "Unit Cost",
            //     quantity: "Quantity",
            //     total_cost: "Line Total",
            //     font_weight: "bold",
            //     color: style.title_fg,
            // }),
            // line_items.iterate_append((item, index) => _render_mail_payment_line_item({
            //     name: item.product.name,
            //     desc: item.product.description,
            //     unit_cost: `${currency} ${(item.total / item.total.quantity).toFixed(2)}`,
            //     quantity: item.quantity.toString(),
            //     total_cost: `${currency} ${item.total.toFixed(2)}`,
            // })),
            // _render_mail_payment_line_item({
            //     unit_cost: "Subtotal",
            //     total_cost: `${currency} ${subtotal.toFixed(2)}`,
            //     font_weight: "bold",
            //     divider: false,
            //     color: style.title_fg,
            // }),
            // _render_mail_payment_line_item({
            //     unit_cost: "Taxes",
            //     total_cost: `${currency} ${subtotal_tax.toFixed(2)}`,
            //     font_weight: "bold",
            //     divider: false,
            //     color: style.title_fg,
            // }),
            // _render_mail_payment_line_item({
            //     unit_cost: "Total",
            //     total_cost: `${currency} ${total.toFixed(2)}`,
            //     font_weight: "bold",
            //     divider: false,
            //     color: style.title_fg,
            // }),
            // show_total_due === false ? null : _render_mail_payment_line_item({
            //     unit_cost: "Total Due",
            //     total_cost: `${currency} ${total_due.toFixed(2)}`,
            //     font_weight: "bold",
            //     divider: false,
            //     color: style.title_fg,
            // }),
        ]
    }

    // On 2fa mail.
    on_2fa_mail({code, username, email, date, ip, device}) {
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;
        return this._mail_template({
            max_width: 400,
            children: [

                // Title.
                TableRow(
                    Title("Verification Required")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("Please confirm your request with this 2FA code.")
                        .center()
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(18)
                ),

                // Auth info.
                [
                    ["Username", username],
                    ["Email", email],
                    ["Date", date],
                    ["Ip Address", ip],
                    ["Device", device],
                ].iterate_append((item) => {
                    return [

                        TableRow(
                            VStack()
                                .margin_right(7.5)
                                // .background("linear-gradient(135deg, #4830C4, #6E399E, #421959)")
                                .background_color(style.text_fg)
                                .border_radius("50%")
                                .frame(5, 5),
                            Text(`<span style='font-weight: 600'>${item[0]}:</span> ${item[1]}`)
                                .color(style.text_fg)
                                .font_size(16)
                                .text_wrap("wrap")
                                .overflow_wrap("break-word")
                                .word_wrap("break-word"),
                        )
                        .wrap(true)
                        .center_vertical(),

                        TableRow().fixed_frame(5, 5),
                    ]
                }),
                
                // 2FA code.
                TableRow(
                    Text(code)
                        .background(style.button_bg)
                        .border_radius("10px")
                        .padding(10, 15)
                        .center()
                        .color(style.button_fg)
                        .width("100%")
                        .margin(20, 0, 0, 0)
                ),

                // Text.
                TableRow(
                    Text("This 2FA code will be valid for 5 minutes.")
                        .color(style.text_fg)
                        .font_style("italic")
                        .font_size(12)
                        .margin_top(20)
                        .center(),
                ),
            ],
        });
    }

    // On successfull payment mail.
    on_payment_mail({payment}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 600,
            children: [

                // Title.
                TableRow(
                    Title("Successful Payment")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We're delighted to inform you that your payment has been successfully processed. Thank you for your purchase.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                ),

                // Image.
                TableRow(
                    Image(`${this.full_domain}/static/payments/party.png`)
                        .frame(60, 60)
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Order Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your order can be found below or in the attachmed invoice pdf.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items: payment.line_items, total_due: true}),
                

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On failed payment mail.
    on_failed_payment_mail({payment}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Payment Failed")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We regret to inform you that your payment has encountered an issue and could not be processed successfully. We understand the inconvenience this may cause. Please try again, please contact customer support if the problem persists.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                ),

                // Image.
                TableRow(
                    ImageMask(`${this.full_domain}/static/payments/error.png`)
                        .frame(40, 40)
                        .mask_color("#E8454E")
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Order Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your failed order can be found below.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items: payment.line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On cancellation mail.
    on_cancellation_mail({payment, line_items}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Successfull Cancellation")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("Your recent cancellation request has been successfully processed.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                ),

                // Image.
                TableRow(
                    Image(`${this.full_domain}/static/payments/check.png`)
                        .frame(40, 40)
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Cancelled Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your cancelled products.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On refund mail.
    on_failed_cancellation_mail({payment}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, ImageMask, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Cancellation Failed")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We regret to inform you that your recent cancellation request has encountered an issue and could not be processed successfully. We understand the inconvenience this may cause. If you believe you are eligible for a cancellation, please try again or contact customer support.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                )
                .center(),

                // Image.
                TableRow(
                    ImageMask(`${this.full_domain}/static/payments/error.png`)
                        .frame(40, 40)
                        .mask_color("#E8454E")
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Cancellation Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your cancellation request.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items: payment.line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On refund mail.
    on_refund_mail({payment, line_items}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Successful Refund")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We're delighted to inform you that your recent refund request has been successfully processed. The charged amount will soon be credited back to your account.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                ),

                // Image.
                TableRow(
                    Image(`${this.full_domain}/static/payments/party.png`)
                        .frame(60, 60)
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Refund Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your refunded products.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On refund mail.
    on_failed_refund_mail({payment, line_items}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, ImageMask, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Refund Failed")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We regret to inform you that your recent refund request has encountered an issue and could not be processed successfully. We understand the inconvenience this may cause. If you believe you are eligible for a refund, please try again or contact customer support.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                )
                .center(),

                // Image.
                TableRow(
                    ImageMask(`${this.full_domain}/static/payments/error.png`)
                        .frame(40, 40)
                        .mask_color("#E8454E")
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Refund Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your refund request.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On refund mail.
    on_chargeback_mail({payment, line_items}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Successful Refund")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We're delighted to inform you that your recent chargeback request has been successfully processed. The charged amount will soon be credited back to your account.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                ),

                // Image.
                TableRow(
                    Image(`${this.full_domain}/static/payments/party.png`)
                        .frame(60, 60)
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Chargeback Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your refundend products.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }

    // On refund mail.
    on_failed_chargeback_mail({payment, line_items}) {

        // Shortcuts.
        const style = this.mail_style;
        const {Title, Text, Image, ImageMask, Table, TableRow, TableData, VStack} = Mail;

        // Create mail.
        return this._mail_template({
            max_width: 800,
            children: [

                // Title.
                TableRow(
                    Title("Chargeback Failed")
                        .color(style.title_fg)
                        .width("fit-content")
                        .font_size(26)
                )
                .center(),

                // Text.
                TableRow(
                    Text("We regret to inform you that your recent chargeback request has been declined.")
                        .margin(10, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                        .center()
                )
                .center(),

                // Image.
                TableRow(
                    ImageMask(`${this.full_domain}/static/payments/error.png`)
                        .frame(40, 40)
                        .mask_color("#E8454E")
                        .margin(0, 0, 30, 0)
                )
                .center(),

                // Title.
                TableRow(
                    Title("Chargeback Summary")
                        .color(style.subtitle_fg)
                        .font_size(18)
                        .margin(0)
                ),
                TableRow(
                    Text("A summary of your chargeback request.")
                        .margin(5, 0, 20, 0)
                        .color(style.text_fg)
                        .font_size(16)
                ),

                // Line items.
                this._render_mail_payment_line_items({payment, line_items}),

                // Bottom spacing.
                VStack()
                    .margin_bottom(15)
            ],
        });
    }
}

// ---------------------------------------------------------
// Exports.

module.exports = Server;
